[{"articleName":"骚年，你还没开始学Flutter吗？","createTime":"2019-05-04T21:49:47.000","lastModifiedTime":"2020-02-03T10:17:41.000","tag":"Flutter","summary":" 开场闲聊\n\n在去年12月份的Flutter Live 2018上，谷歌的Flutter团队宣布*","imageAddress":"/img/study_flutter.png","articleAddress":"/config/study/骚年，你还没开始学Flutter吗？.md","articleContent":"---\ntitle: 骚年，你还没开始学Flutter吗？\ndate: 2019-05-04 21:49:47\nindex_img: /img/study_flutter.png\ntags: Flutter\n---\n\n# 开场闲聊\n\n在去年12月份的Flutter Live 2018上，谷歌的Flutter团队宣布**Flutter 1.0 release版**正式发布。\n\n想必很多小伙伴和我一样，都是从那个时候开始了解到Flutter的，而我也是顺带从那个时候入了Flutter的坑。\n\n不过应该还有一部分小伙伴对Flutter只是略有耳闻，甚至闻所未闻。为了把这部分小伙伴拉到这个 **“大坑”** 里面来，我不得不在这里向你们展示**Flutter的魅力**所在，同时为了保持客观公正，我也会介绍一些我遇到过的**Flutter的麻烦**之处。  \n就像谈恋爱一样，因为优点才会在一起，也因为接受得了缺点才能使情感继续保持。\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/001.png)\n\n\n话不多说，接下来就由我来为诸位展示Flutter所具备的这些的特性吧。\n<!--more--> \n\n\n# Flutter的特性\n\n在我看来，Flutter的特性主要分为两类，分别是**高效性**与**舒适性**，这两者都会是你在进行Flutter开发时最直观的感受，而下面的这些特性从侧面也会展示出这部分效果\n\n\n### 一、热重载\n\n热重载大家应该都耳熟能详了，和前端开发一样，对代码进行修改后，可以即时看到效果，这点相比于原生开发每次做了一点修改就要从头到尾编译一次不知道高到哪里去了！\n\n下面是一点简单的演示效果：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/002.gif)\n\n可以看到，热重载带来的体验提升是巨大的！作为一名原生开发者，你心动了吗？\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/003.gif)\n\n不过关于热重载还有一些需要说明的地方，在用到可以保存状态的控件时，热重载不能将状态重置，比如说一个动画控件，在动画结束后再进行热重载是无法再次播放动画的（除非你对动画做了循环处理），所以有的时候你看着觉得热重载没效果，这时候就要考虑是不是用到了 **StatefulWidget** 之类的控件。\n\nFlutter将热重载作为一个亮点，不过由于Flutter的布局是用代码去写的，和Android中的xml不同，它无法进行实时预览，所以你无法想象没有热重载的话，要怎么面对Flutter进行编程，这么看来热重载既是亮点，也是要点。\n\n### 二、万物基于Widget\n\nFlutter中的页面都是由一个个的Widget组合而成，甚至连页面本身也是一个Widget，Widget与android中的组件类似，不过前者具有更好的组合性。  \n同时Flutter已经封装了许多简单好用的Widget，使用起来非常方便。\n\n比如在android中你想创建下面这样一个圆，你需要重新写一个xml，并在xml定义各种属性：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/004.png)\n\n而在Flutter中实现是非常容易的：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/005.png)\n\n不管是圆形，还是圆角矩形，又或者是不对称圆角矩形，Flutter都提供了很方便的实现方法。\n\n关于Widget可以看到代码的结构是一层一层的，对于初次接触的人来说想必是很难接受这种代码格式。因为我当初看到Flutter这样的代码时，还产生过劝退的想法，不过写了一段时间后还是觉得蛮带感的。打个比方的话就像初见JoJo和再见JoJo的感觉。\n\n在android中视图在xml中，代码则由java负责，在习惯了flutter后，我觉得用代码直接去创建视图也未尝不是一种好的解决方法，毕竟xml+java也算历史悠久了。而我也接触过一个前端框架——Vue，flutter的这种结构和vue的就非常类似。\n\n孰好孰坏因人而异，想必等你使用过一段时间后的flutter后心中会有着一个自己的答案。\n\n\n### 三、跨平台\n\n跨平台其实是flutter最突出的一个特点了，与其他如React、Week这类跨平台框架不同，Flutter作为后起之秀能脱颖而出与其性能表现和稳点程度是有很大关系的。\n\n在Flutter Live 2018上，官方已经放出了好几个纯Flutter的应用，并演示了他们在android和ios上的运行效果，其中最为惊艳的就是 **《The History Of Everything》** 了，下面给大家简单的展示一下真机运行效果：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/007.gif)\n\n想自行体验的话可以去Google Play或者App Store中下载\n\n上面应用中的动画大部分由 **Flare** 实现，具体可以参见 [2dimensions(需科学上网)](https://www.2dimensions.com/)，这样可以跑满60帧的矢量动画也只是Flutter性能展现的一面，在跨平台上，其最大的特点就是**接近原生效果**。\n\n不过目前而言，flutter在跨平台上有一些问题还是需要完善的。比如视频的播放  \n具体原因可以看这篇文章：[万万没想到——flutter这样外接纹理](https://www.yuque.com/xytech/flutter/pfpo68)\n\n还有那些需要用到第三方sdk的时候，可能就需要做双端的channel通信了，但是也有比较积极的团队专门做了flutter的sdk，**声网**就是其中之一\n\n### 四、年轻\n\n年轻是flutter的一大优势，同时也是一大劣势。\n\n就像上面说的，许多第三方sdk还没有开始为flutter做适配，所以flutter的开发生态自然比不了其他技术框架和平台，然而因其发展的势头非常迅猛，所以这其实也是一个机会。大量的开发者可以在这个领域再做建树，未来会是何种状况还是非常令人期待的。\n\n如同 **Kotlin** 一样，现阶段如果去看国外的一些技术博客，如 **Medium** 里关于 Android 的，大部分语言都已经是kotlin的了，只是国内的博客可能普及度还没有那么高。但是良禽择木而栖，趋势一直都在，怎么选择就看个人了。\n\n也正是因为flutter比较年轻，所以有些东西还没有一个既定的公认的解决方案。就比如flutter开发过程中都会遇到的 **状态管理**。\n\n目前flutter中的状态管理框架有许多，最知名的比如从前端引鉴过来的 **Redux**，同时还有 **Bloc**， **Provide** 等。每个状态管理框架解决的范围都不一样，学习成本也各有差异，如何选择还是需要看项目需求与个人喜好。  \n具体选择可以看这篇文章：[（译）让我来帮你理解和选择Flutter状态管理方案](https://juejin.im/post/5bac54c45188255c681589d3)\n\n\n### 五、Dart语言\n\nflutter的开发语言使用的是dart，对于刚接触kotlin的同学来说，再去使用dart想必是一件很苦恼的事情。\n\n比如kotlin中用 **var表示变量(variable)**，**val表示常量(value)**，而到了dart中虽然可以用var表示变量，但是常量还是只能用final或者const去修饰。\n\n从很多方面看来kotlin都算是算是采各家所长集于一身，而dart则像是修行还没结束就半路出山了。\n\n不过因为对比对象是kotlin，所以dart显得不那么出色，其实dart还是有很多好用的点的。\n\n比如\n#### 调用前做对象判空：\n\n```\n//kotlin\na?.m()\n//dart\na?.m()\n\n```\n不同之处在于kotlin如果对象为空则不做处理,同时要求你做对象为空时的赋值，dart如果对象为空则返回null,\n\n#### 对象为空时赋值\n\n```\n//kotlin\nvar x = a?.b ?: c\n//dart\nvar x = a?.b ?? c\n```\n两者区别不大.不过dart中还可以使用 ??= 代替?? ,区别是前者可以单独作为赋值语句\n\ndart虽然在使用上不及kotlin那么舒适，但dart也一直在更新换代，优秀的语言发展到最后一定是有很多共同性的，所以不要过于纠结于语言的选择上，因为它终究只是一种工具。\n\n# 结束闲聊\n\n从去年12月flutter发布1.0 release版本到今天，flutter已经迭代了好多个版本了\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/008.png)\n\n而我在使用过程中确实遇到过一些问题，或简单或麻烦，但大部分都有了解决方案。从稳定性上来讲，使用flutter的交互其实就是对数据进行操作，而正是因为这样，做到了视图与数据分离，所以出bug的情况要少得多。\n\n为什么我要介绍flutter甚至是鼓励各位原生开发者们去学flutter，主要原因有两个：\n- 一、学习flutter的成本很低，因为它难度不大\n- 二、从flutter的性能表现上来看，它是可以代替原生应用的，只是现在火候不够\n\n所以对于现阶段的初中级原生开发者而言，我建议你一定要抽出时间去了解了解flutter，因为大部分你能通过原生去实现的东西，用flutter一样也是可以的，并且还更加轻松，还可以跨平台。\n\n写到这里，文章中也很少涉及到技术上的东西，主要还是以介绍为主\n\n下面再介绍一点点我非常推荐的学习flutter的途径吧：\n\n\n\n1、 **首先自然是Youtube上flutter官方的视频项目(科学上网)：\n[Flutter](https://www.youtube.com/channel/UCwXdFgeE9KYzlDdR7TG9cMw)**\n\n这里面有个超赞的系列，就是每周一更的 **Flutter Widget of the Week**\n\n\n2、**然后你也可以关注B站的** **[Google中国账号](https://space.bilibili.com/64169458/)**\n\n其中的视频都有中文翻译，可以找到关于flutter的学习视频，不过和youtube上相比更新要慢很多\n\n3、**[《Flutter实战》](https://book.flutterchina.club/)**\n\n万分感谢这位作者开源这本技术书！\n\n\n剩下的学习途径还有许多，不过学习也是发散的，知道上面三个后，其他的途径于你也不在话下了。\n\n\n最后再介绍一个学习途径\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/apk/apk.png)\n\n没错，就是我用flutter写的一个小项目\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/introduce_flutter/009.jpg)\n\n"},{"articleName":"Flutter图文混排原生实现方案","createTime":"2019-04-19T21:49:47.000","lastModifiedTime":"2020-02-03T10:37:02.000","tag":"Flutter","summary":" 开头\n\n图文混排在移动端的实现方案主要有两大种，比如通过HTML去做一个WebView的富文本，","imageAddress":"/img/pic_text.png","articleAddress":"/config/study/Flutter图文混排原生实现方案.md","articleContent":"---\ntitle: Flutter图文混排原生实现方案\ndate: 2019-04-19 21:49:47\nindex_img: /img/pic_text.png\ntags: Flutter\n---\n\n# 开头\n\n图文混排在移动端的实现方案主要有两大种，比如通过HTML去做一个WebView的富文本，或者通过原生的方式去实现。\n\n使用WebView在性能上自然不及原生实现，同时开发者需要具备一定的前端知识，它最大的优势是跨平台;\n\n出于性能的考虑，以及我对前端知识的了解程度，这里我只是介绍一下如何通过原生的方式去实现图文混排。\n<!--more--> \n\n# 介绍\n\n在手机上，你经常能看到这样的图文实现方式，比如贴吧的这种：\n\n<img src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Flutter%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/001.png\" width = \"600\" height = \"300\" div align=center />\n\n点进去后是这样的展示：\n\n\n<img src=\"https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Flutter%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/002.png\" width = \"400\" height = \"720\" div align=center />\n\n\n这种实现方式比较简单，算是文字与图片分开展示。不过既然我们要实现的是图文混排，那一定会稍稍复杂一点。\n\n# 示例\n\n下面是demo的效果：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Flutter%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/003.gif)\n\n\n从上面的demo可以看到，通过原生的图文混排实现了下面这些效果：\n\n    1.单个图片的插入\n    2.多个图片的插入\n    3.插入图片时对文字进行切割\n    4.删除图片时对文字进行合并\n\n\n其实看到这里，你应该能够看得出来一个大致的实现方法了，接下来我来介绍一下整个图文混排的结构。\n\n由于是用Flutter实现，所以图文混排用的ListView，如果是android的话则可以使用RecyclerView(ios的话我不太了解所以就不说了)，因为实现图文混排主要是对数据的处理，所以平台的限制不大。\n\n**既然是ListView，可以看得出来，ListView的内容全部是由Image与TextField组成，每当你插入一个Image的时候，同时会新増一个TextField，而这个TextField的内容则是上个TextField光标后的文字。**\n\n既然知道了结构，那么下面来看一下是如何实现的吧。\n\n\n# 实现\n\n图文混排的主要逻辑在于两个：\n\n    1.插入\n    2.删除\n\n在进行操作之前，先定义一个抽象的结构，用于存储字符串数据，其实只是对MapEntry的一个简单修改：\n\n\n```\nclass TextEntry<K, V> {\n  K key;\n  V value;\n  factory TextEntry(K key, V value) = TextEntry<K, V>._;\n  TextEntry._(this.key, this.value);\n  String toString() => \"TextEntry($key: $value)\";\n}\n```\n\n\n然后来看一下插入的实现：\n\n## 插入\n\n```\nclass RichTextList<T>{\n\n  List<TextEntry<T, String>> _list = [];\n\n  void insertOne(int currentPosition, String beforeText, String selectText,\n      String afterText, T t) {\n    _list[currentPosition].value = beforeText;\n    _list.insert(currentPosition + 1, TextEntry(t, \"\"));\n    _list.insert(currentPosition + 2, new TextEntry(null, afterText));\n  }\n\n}\n```\n传递的参数中各个的意义如下：\n\n- currentPosition：当前TextField所在的位置\n- beforeText：当前TextField中光标前的文字\n- selectText：当前TextField中选中的文字，在这里没有进行处理\n- afterText：当前TextField中光标后的文字\n- t：你传入的泛型参数\n\n可以看到，每插入一个数据，还会自动插入一个value为null的TextEntry，而这个Entry则是文字的内容：\n\n```\n_list.insert(currentPosition + 2, new TextEntry(null, afterText));\n```\n\n所以图文混排的关键在于有一个统一的数据结构，后续如果想对这个数据结构进行转换也可以依据这个来，value为空的TextEntry表示文字，其他的则是你传入的泛型参数。\n\n下面是插入多条的代码：\n\n\n```\n  void insert(int currentPosition, String beforeText, String selectText, String afterText, List<T> list){\n    _list[currentPosition].value = beforeText;\n    for(int i = 0; i < list.length; i++){\n      _list.insert(currentPosition + 2*i + 1, TextEntry(list[i], \"\"));\n      _list.insert(currentPosition + 2*i + 2, new TextEntry(null, i == list.length - 1?afterText:\"\"));\n    }\n  }\n```\n\n当然，你可以用插入多个的替代上面插入单个的。\n\n然后就是删除的逻辑了：\n\n## 删除\n\n删除也非常简单：\n\n\n```\n  void remove(int currentPosition) {\n      String afterText = _list[currentPosition + 1].value;\n      _list[currentPosition - 1].value += afterText;\n      _list.removeAt(currentPosition + 1);\n      _list.removeAt(currentPosition);\n  }\n```\n\n删除的主要逻辑在于把下一个TextField中的内容补在上一个TextField中\n\n\n核心的逻辑大概就是这样。\n\n\n其中有点不方便的就是可能会与你的数据结构不太相同，所以转换的工作需要自己另外实现，当然如果你不想使用抽象的结构也可以自己自定义一种，比如说下面这种：\n\n\n```\nclass CustomTypeList{\n  TypeFlag flag;//默认为文字——0：文字，1：图片，2：视频，3：音乐\n  var imageUrl;\n  CustomTypeList({this.flag = TypeFlag.text, this.imageUrl = \"\"});\n}\n\nenum TypeFlag{\n  text,\n  image,\n  video,\n  music\n}\n```\n实际使用中可以把枚举类型替换成int值，这样配合后端更佳。\n\n**通过ListView实现图文混排最大的一个优势在于你可以将文字与任何类型的布局混合在一起，可以是图片，可以是视频，也可以是音乐！**\n\n\n# 结尾\n\n这篇文章没有把全部的代码贴出来，我已经把demo放在仓库里了，小伙伴们有意向可以去下载查看。\n\n[**项目地址**](https://github.com/asjqkkkk/TextPicList)\n\n最后的最后，为我用纯Flutter写的一个测试项目打个小广告：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/apk/apk.png)\n\n如果你对于上面图文混排最后的效果不是特别满意，也可以到上面的app(android版)里面瞧一下,有做过特殊处理哦！"},{"articleName":"Android Studio自定义模板实现一键创建MVP结构","createTime":"2018-12-02T21:49:47.000","lastModifiedTime":"2020-02-03T10:12:55.000","tag":"Android","summary":" 前言\r\n\r\n之前有写过关于如何使用 DataBinding 的两篇文章，不仅仅是为了消灭掉一部分","imageAddress":"/img/create_mvp.png","articleAddress":"/config/study/Android Studio自定义模板实现一键创建MVP结构.md","articleContent":"---\ntitle: Android Studio自定义模板实现一键创建MVP结构\ndate: 2018-12-02 21:49:47\nindex_img: /img/create_mvp.png\ntags: Android\n---\n\n# 前言\r\n\r\n之前有写过关于如何使用 DataBinding 的两篇文章，不仅仅是为了消灭掉一部分重复代码，更是为了提高开发效率。详情可以点击下方的传送门  \r\n[DataBinding——从路人到好友（一）：初遇](https://oldchen.top/2018/10/17/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E8%B7%AF%E4%BA%BA%E5%88%B0%E5%A5%BD%E5%8F%8B%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%88%9D%E9%81%87/)  \r\n[DataBinding——从相识到相知（二）：互酌](https://oldchen.top/2018/10/20/DataBinding%E2%80%94%E2%80%94%E4%BB%8E%E7%9B%B8%E8%AF%86%E5%88%B0%E7%9B%B8%E7%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BA%92%E9%85%8C/)\r\n\r\n<!--more--> \r\n\r\n而这篇文章主要介绍的就是如何通过 Android Studio 提供的模版功能去自定义模版结构，从而实现类似于一键创建整个MVP代码的功能。可以说在提高效率的道路上，又向前走了一大步\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/001.jpg)\r\n\r\n下面可以来看一看具体效果：\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/002.gif)\r\n\r\n# 介绍\r\n\r\n在 Android Studio 中，创建一个 Activity 可以直接通过 **File -> New -> Activity** 来进行选择创建\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/003.png)\r\n\r\n通过这种方式创建的 Activity 会自动在 AndroidManifest.xml 中完成注册，创建其他组件也可以通过这种方式。\r\n\r\n不过，如果你正在使用某种开发模式，譬如 **MVP、MVVM** 等，你每创建一个 Activity 就意味着需要同时创建一系列其他相关的类。\r\n\r\n为了避免这种毫无意义的重复性劳动，我们可以编写模板代码去实现一键创建重复代码。\r\n\r\n# 开始\r\n\r\n下面我们就来开始模版的编写吧。\r\n\r\n首先，找到你的 **Android Studio** 的安装目录，然后根据这个目录找到 **...\\templates** 目录：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/004.png)\r\n\r\n然后进入 **activityes** 目录，我们将要编写的各种模版就在这个目录内：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/005.png)\r\n\r\n要说如何去编写模版代码，一开始我也是一无所知的，不过好在 Android Studio 已经为我们提供了这些例子，我们直接参考例子去写。\r\n\r\n就拿最简单的 **Empty Activity** 来开始吧\r\n\r\n进入到 **EmptyActivity** 目录\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/006.png)\r\n\r\n## globals.xml.ftl\r\n\r\n打开 **globals.xml.ftl** 文件，下面是它的内容：\r\n\r\n```\r\n<?xml version=\"1.0\"?>\r\n<globals>\r\n    <global id=\"hasNoActionBar\" type=\"boolean\" value=\"false\" />\r\n    <global id=\"parentActivityClass\" value=\"\" />\r\n    <global id=\"simpleLayoutName\" value=\"${layoutName}\" />\r\n    <global id=\"excludeMenu\" type=\"boolean\" value=\"true\" />\r\n    <global id=\"generateActivityTitle\" type=\"boolean\" value=\"false\" />\r\n    <#include \"../common/common_globals.xml.ftl\" />\r\n</globals>\r\n\r\n```\r\n\r\n根据文件名来看， **globals.xml.ftl** 的作用是用来控制一些全局变量，比如是否显示 **ActionBar** 等，暂且先不用管它\r\n\r\n## recipe.xml.ftl\r\n\r\n **recipe.xml.ftl** 文件内容如下：\r\n \r\n```\r\n<?xml version=\"1.0\"?>\r\n<#import \"root://activities/common/kotlin_macros.ftl\" as kt>\r\n<recipe>\r\n    <#include \"../common/recipe_manifest.xml.ftl\" />\r\n    <@kt.addAllKotlinDependencies />\r\n\r\n<#if generateLayout>\r\n    <#include \"../common/recipe_simple.xml.ftl\" />\r\n    <open file=\"${escapeXmlAttribute(resOut)}/layout/${layoutName}.xml\" />\r\n</#if>\r\n\r\n    <instantiate from=\"root/src/app_package/SimpleActivity.${ktOrJavaExt}.ftl\"\r\n                   to=\"${escapeXmlAttribute(srcOut)}/${activityClass}.${ktOrJavaExt}\" />\r\n    <open file=\"${escapeXmlAttribute(srcOut)}/${activityClass}.${ktOrJavaExt}\" />\r\n\r\n</recipe>\r\n\r\n```\r\n\r\n第一段\r\n\r\n        <#import \"root://activities/common/kotlin_macros.ftl\" as kt>\r\n\r\n就是用于导入Kotlin的相关命令，同时它的别名为 **kt**\r\n\r\n主要还是注意 **instantiate** 代码块中的相关信息， 其中 **${ktOrJavaExt}** 表示当你创建模版的时候，创建的 **.java** 文件还是 **.kt** 文件，而相对应的，你需要在编写模版例子的时候分别写上对应的两份 **Java** 与 **Kotlin** 代码\r\n\r\n**open** 代码块就是创建模版后，默认打开的文件\r\n\r\n# template.xml\r\n\r\n**template.xml** 代码略长，这里只是贴出了大致代码\r\n\r\n```\r\n<?xml version=\"1.0\"?>\r\n<template\r\n    format=\"5\"\r\n    revision=\"5\"\r\n    name=\"Empty Activity\"\r\n    minApi=\"9\"\r\n    minBuildApi=\"14\"\r\n    description=\"Creates a new empty activity\">\r\n\r\n    <category value=\"Activity\" />\r\n    <formfactor value=\"Mobile\" />\r\n\r\n    <parameter\r\n        id=\"activityClass\"\r\n        name=\"Activity Name\"\r\n        type=\"string\"\r\n        constraints=\"class|unique|nonempty\"\r\n        suggest=\"${layoutToActivity(layoutName)}\"\r\n        default=\"MainActivity\"\r\n        help=\"The name of the activity class to create\" />\r\n        \r\n        \r\n        ...\r\n\r\n    <!-- 128x128 thumbnails relative to template.xml -->\r\n    <thumbs>\r\n        <!-- default thumbnail is required -->\r\n        <thumb>template_blank_activity.png</thumb>\r\n    </thumbs>\r\n\r\n    <globals file=\"globals.xml.ftl\" />\r\n    <execute file=\"recipe.xml.ftl\" />\r\n\r\n</template>\r\n\r\n```\r\n我们挑出其中的重点来说\r\n\r\n```\r\n<category value=\"Activity\" />\r\n```\r\n表示当前的这个模版的分类，当前的 **Value** 是 **Activity** ，就表示它会出现在 **File -> New -> Activity** 中，这个是可以自定义的.\r\n\r\n```\r\n        <thumbs>\r\n        <!-- default thumbnail is required -->\r\n        <thumb>template_blank_activity.png</thumb>\r\n        </thumbs>\r\n```\r\n**thumbs** 用于指定创建模版时所展示出来的图片\r\n\r\n而最重要的，还是 **parameter** 代码块的内容了，在这之中，我们只需要关注以下几个，其他的顾名思义即可。\r\n\r\n\r\n```\r\n    <parameter\r\n        id=\"activityClass\"\r\n        name=\"Activity Name\"\r\n        type=\"string\"\r\n        constraints=\"class|unique|nonempty\"\r\n        suggest=\"${layoutToActivity(layoutName)}\"\r\n        default=\"MainActivity\"\r\n        help=\"The name of the activity class to create\" />\r\n\r\n```\r\n**activityClass** 表示所要创建的 Activity ，其中 **default** 为默认名。\r\n\r\n\r\n```\r\n    <parameter\r\n        id=\"generateLayout\"\r\n        name=\"Generate Layout File\"\r\n        type=\"boolean\"\r\n        default=\"true\"\r\n        help=\"If true, a layout file will be generated\" />\r\n```\r\n上面的代码块表示是否同时自动创建一个Activity对应的布局\r\n\r\n\r\n```\r\n  <parameter\r\n        id=\"layoutName\"\r\n        name=\"Layout Name\"\r\n        type=\"string\"\r\n        constraints=\"layout|unique|nonempty\"\r\n        suggest=\"${activityToLayout(activityClass)}\"\r\n        default=\"activity_main\"\r\n        visibility=\"generateLayout\"\r\n        help=\"The name of the layout to create for the activity\" />\r\n```\r\n **layoutName** 则表示布局的名字，这里的 **suggest** 属性所填写的内容即为布局名，**${activityToLayout(activityClass)}**则为跟随Activity的名字，其中 **activityClass** 是Activity名字的引用\r\n \r\n 剩下的不用再作说明，基本上可以见名知意。\r\n \r\n# 模版代码\r\n\r\n接下来我们从 **EmptyActivity** 中的 **root** 目录一直进入，直到看到下面两个文件\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/007.png)\r\n\r\n可以看到，一个后缀是 **java.ftl** 另外一个后缀是 **kt.ftl**，他们分别用于创建 Java模版与Kotlin模版，如果你暂时不使用Kotlin的话，可以不用去关心 Kotlin模版，当你完成了Java模版的编写，也可以使用 Android Studio自带的转换功能，还是蛮方便的。\r\n\r\n下面来看一下Java的模版代码：\r\n\r\n```\r\npackage ${packageName};\r\n\r\nimport ${superClassFqcn};\r\nimport android.os.Bundle;\r\n<#if (includeCppSupport!false) && generateLayout>\r\nimport android.widget.TextView;\r\n</#if>\r\n\r\npublic class ${activityClass} extends ${superClass} {\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n<#if generateLayout>\r\n        setContentView(R.layout.${layoutName});\r\n       <#include \"../../../../common/jni_code_usage.java.ftl\">\r\n<#elseif includeCppSupport!false>\r\n\r\n        // Example of a call to a native method\r\n        android.util.Log.d(\"${activityClass}\", stringFromJNI());\r\n</#if>\r\n    }\r\n<#include \"../../../../common/jni_code_snippet.java.ftl\">\r\n}\r\n\r\n```\r\n- ${packageName}：表示当前包名\r\n- ${activityClass}：表示当前的Activity名字\r\n- ${superClass}：表示继承的Activity，同时为了让这个父类生效，需要在import中加入${superClassFqcn}\r\n- ${layoutName}：当前Activity所对应的布局名\r\n\r\n目前我们只需要关注上面这部分，接下来可以看一下我们实际想要创建的MVP结构：\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/008.png)\r\n\r\n编写模版代码前，最好的方式是先写一遍例子，然后对照例子去替换关键名部分，这样做是最轻松的。\r\n\r\n下面就来看一看具体的实现吧：\r\n\r\n# 样例代码\r\n\r\n\r\n## 接口部分：TestActivityContact\r\n\r\n\r\n```\r\npackage com.example.testcustomtemplates.contact;\r\n\r\npublic interface TestActivityContact {\r\n    interface Presenter<T> {\r\n        void succeed(T t);\r\n        void failed(T t);\r\n        void error(Throwable e);\r\n        void subscribe();\r\n        void unSubscribe();\r\n    }\r\n\r\n    interface View<T> {\r\n        void setPresenter(Presenter presenter);\r\n        void succeed(T t);\r\n        void failed(T t);\r\n        void error(Throwable e);\r\n    }\r\n    \r\n    interface Model {\r\n        void setPresenter(Presenter presenter);\r\n    }\r\n}\r\n```\r\n为了方便测试，这里并没有另外创建一些基类接口，可以看到上面代码中分别对应 MVP 结构中三个模块的接口，写的是最基本的需求方法，不过 MVP 也不都是完全一样的，这里你可以定义自己想写的方法。\r\n\r\n## Model层：TestActivityModel\r\n\r\n\r\n```\r\npackage com.example.testcustomtemplates.model;\r\n\r\nimport android.content.Context;\r\nimport com.example.testcustomtemplates.contact.TestActivityContact;\r\n\r\npublic class TestActivityModel implements TestActivityContact.Model {\r\n\r\n    private Context context;\r\n    private TestActivityContact.Presenter mPresenter;\r\n\r\n    public TestActivityModel(Context context) {\r\n        this.context = context;\r\n    }\r\n\r\n    @Override\r\n    public void setPresenter(TestActivityContact.Presenter presenter) {\r\n        this.mPresenter = presenter;\r\n    }\r\n}\r\n```\r\nModel层主要就是做一些网络请求，存储之类的数据相关操作，不可以持有对View的引用，他是通过Presenter去和View进行交互的。\r\n\r\n## Presenter层：TestActivityPresenter\r\n\r\n\r\n```\r\npackage com.example.testcustomtemplates.presenter;\r\n\r\nimport android.content.Context;\r\nimport com.example.testcustomtemplates.contact.TestActivityContact;\r\nimport com.example.testcustomtemplates.model.TestActivityModel;\r\n\r\npublic class TestActivityPresenter<T> implements TestActivityContact.Presenter<T> {\r\n\r\n    private TestActivityContact.View mView;\r\n    private TestActivityModel mModel;\r\n    private Context context;\r\n\r\n    public TestActivityPresenter(TestActivityContact.View mView, Context context) {\r\n        this.mView = mView;\r\n        this.context = context;\r\n        mModel = new TestActivityModel(context);\r\n\r\n    }\r\n    @Override\r\n    public void succeed(T t) {\r\n\r\n    }\r\n    @Override\r\n    public void failed(T t) {\r\n\r\n    }\r\n    @Override\r\n    public void error(Throwable e) {\r\n\r\n    }\r\n    @Override\r\n    public void subscribe() {\r\n\r\n    }\r\n    @Override\r\n    public void unSubscribe() {\r\n\r\n    }\r\n}\r\n```\r\nPresenter层自然不必多说，他最好是不要持有View控件的引用，大部分的逻辑操作需要他来完成，不过不可避免的，如果业务逻辑复杂了，Presenter层也会变得臃肿，这也是MVP结构的一个短处。\r\n\r\n## View层：TestActivity\r\n\r\n```\r\npackage com.example.testcustomtemplates.activity;\r\n\r\nimport android.support.v7.app.AppCompatActivity;\r\nimport android.os.Bundle;\r\nimport com.example.testcustomtemplates.R;\r\nimport com.example.testcustomtemplates.contact.TestActivityContact;\r\nimport com.example.testcustomtemplates.presenter.TestActivityPresenter;\r\n\r\npublic class TestActivity<T> extends AppCompatActivity implements TestActivityContact.View<T> {\r\n\r\n    private TestActivityContact.Presenter mPresenter;\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_test);\r\n        new TestActivityPresenter<T>(this, this);\r\n    }\r\n\r\n    @Override\r\n    public void setPresenter(TestActivityContact.Presenter presenter) {\r\n        this.mPresenter = presenter;\r\n    }\r\n\r\n    @Override\r\n    public void succeed(T t) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void failed(T t) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void error(Throwable e) {\r\n\r\n    }\r\n}\r\n\r\n```\r\nActivity或者Fragment都可以用作View层，这层主要是对一些视图控件的状态进行切换，不做复杂的逻辑操作。\r\n\r\n看完上面的这些代码后，其实就可以开始直接编写我们的模版代码了。\r\n\r\n# 模版编写\r\n\r\n首先，可以Copy一份 **EmptyActivity** 整个模版的文件，然后改一下名字，随便什么都可以，这里我将其改成 **MvpDemoActivity**\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/009.png)\r\n\r\n然后我们首先对 **template.xml** 文件进行修改，主要修改下面这个部分：\r\n\r\n\r\n```\r\n<category value=\"Activity\" />\r\n```\r\n然后是对 **recipe.xml.ftl** 文件进行修改，修改后如下：\r\n\r\n\r\n```\r\n<?xml version=\"1.0\"?>\r\n<#import \"root://activities/common/kotlin_macros.ftl\" as kt>\r\n<recipe>\r\n    <#include \"../common/recipe_manifest.xml.ftl\" />\r\n    <@kt.addAllKotlinDependencies />\r\n\r\n<#if generateLayout>\r\n    <#include \"../common/recipe_simple.xml.ftl\" />\r\n    <open file=\"${escapeXmlAttribute(resOut)}/layout/${layoutName}.xml\" />\r\n</#if>\r\n\r\n\t<!--View-activity-->\r\n    <instantiate from=\"root/src/app_package/MvpActivity.java.ftl\"\r\n                   to=\"${escapeXmlAttribute(srcOut)}/activity/${activityClass}.java\" />\r\n\t<!--Model-->\r\n\t<instantiate from=\"root/src/app_package/MvpModel.java.ftl\"\r\n                   to=\"${escapeXmlAttribute(srcOut)}/model/${activityClass}Model.java\" />\t\r\n\t<!--Contact-->\r\n\t<instantiate from=\"root/src/app_package/MvpContact.java.ftl\"\r\n                   to=\"${escapeXmlAttribute(srcOut)}/contact/${activityClass}Contact.java\" />\r\n\t<!--Presenter-->\r\n\t<instantiate from=\"root/src/app_package/MvpPresenter.java.ftl\"\r\n                   to=\"${escapeXmlAttribute(srcOut)}/presenter/${activityClass}Presenter.java\" />\t   \r\n    <open file=\"${escapeXmlAttribute(srcOut)}/activity/${activityClass}.java\" />\r\n\r\n</recipe>\r\n\r\n```\r\n\r\n上面的代码表示只编写了Java版，当然你在修改这个文件之前还是需要创建相对应的几个类的模版代码的。这里出于篇幅考虑暂时就不贴出实际的模版代码了，下面会给出github地址，编写了Java版和Kotlin版的，大家可以拿去参考\r\n\r\n[Github项目链接](https://github.com/asjqkkkk/TemplatesTest)\r\n\r\n当然，有好的模版也可以一起分享一下\r\n\r\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E4%B8%80%E9%94%AE%E5%88%9B%E5%BB%BAMVP%E7%BB%93%E6%9E%84/010.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},{"articleName":"Room Database入门指南","createTime":"2018-10-30T21:49:47.000","lastModifiedTime":"2020-02-03T10:05:21.000","tag":"Android","summary":"说到Android端有哪些可以使用的数据库，大家首先想到的自然是SQLite这种带有官方属性加持的轻","imageAddress":"/img/room_database.png","articleAddress":"/config/study/Room Database入门指南.md","articleContent":"---\ntitle: Room Database入门指南\ndate: 2018-10-30 21:49:47\nindex_img: /img/room_database.png\ntags: Android\n---\n\n说到Android端有哪些可以使用的数据库，大家首先想到的自然是SQLite这种带有官方属性加持的轻型的数据库。\n\n不过对于像我这种基本上没有接触过SQL数据库语言编写的人来说，要通过去写难以查错且又毫不熟悉的数据库代码才能操作数据库的话，那就太令人头大了。\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/001-001.jpg)\n\n于是乎，便于Android开发者操作数据库的框架也就多了起来，其中人气较高的就有GreenDao、Realm，ObjectBox等，而Room则是谷歌官方十分推荐的，可以代替SQlite的不二之选。\n\n本篇的主要介绍对象也是Room数据库，不过在此之前，还得简单介绍一下上面提到过的其他几位，同时做个小小的对比。\n\n# 一、介绍与比较\n\n\n由于我用过的数据库框架并不多，所以对于用过的可以说一下感受，没用过的就简单带过了。\n\n## 介绍\n\n### GreenDao 和 ObjectBox \n\n在这些数据库中， **GreenDao** 算是早闻其名，不过一直没有用过，后来它的作者又出了个 **ObjectBox** ，而且你可以在 [**GreenDao**的GitHub页面](https://github.com/greenrobot/greenDAO) 找到推荐使用 **ObjectBox** 的 [ObjectBox地址](https://objectbox.io/) .\n\n### Realm\n\n我真正使用过的还只有 **Realm** 数据库，这里要提一下，**Realm** 数据库对于中国的开发者非常的友好，就像大名鼎鼎的Glide一样， **Realm** 也有中文的介绍文档，文档地址在此：  \n[开始使用Realm](https://realm.io/cn/docs/java/latest/)  \n虽然这份文档对应的版本不是最新的. 不过对于初次接触 **Realm** 人来说，看这份文档就可以上手了\n\n最开始使用Realm的时候也是碰过不少坑，不过最主要的是所有数据库对象需要继承 **RealmObject** 这个类(也可以通过接口实现)，这样对项目已有的数据结构不太友好，同时我还发现继承了 **RealmObject** 的对象并不能与 **Gson** 完美结合，如果需要转换的话，还是得费一番周折的。\n种种原因，导致我最后从项目中抽去了Realm这个数据库.\n\n### Room\n\n与 Realm 分手后的日子里，我并没有放弃对新的数据库的寻找，后来在浏览 Google官方文档的时候才发现了 **Room** 这个新的数据库，经过我一番使用后，就决定是它了！\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/001-002.jpg)\n\n\n## 比较\n\n因为懒惰的原因，我并没有做过深入的测试，下面会给出从网上找到的关于这些数据库的对比，原文地址如下：\n\n[**Realm, ObjectBox or Room. Which one is for you?**](https://notes.devlabs.bg/realm-objectbox-or-room-which-one-is-for-you-3a552234fd6e)\n\n然后是数据量达到 **100k/10k** 的时候，进行增删改查等操作消耗的时间对比：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/001.jpeg)\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/002.jpeg)\n\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/003.jpeg)\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/004.jpeg)\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/005.jpeg)\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/006.jpeg)\n\n可以看到，在各个方面，统统都是 **ObjectBox** 傲视群雄。  \n那这篇文章为什么还是要写介绍关于 **Room Database** 呢？\n\n首先是官方Buff加持，和介绍文档里的一句话：  \n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/007.png)  \n[这里是Room的官方介绍文档地址](https://developer.android.google.cn/training/data-storage/room/)\n\n大致意思就是：**我们强烈建议你用Roon去代替SQLite，不过如果你是个铁头娃非得用SQLite，那我们也没有办法。**\n\n除了上面这段话，还有一点也可以作为选择Room的原因，就是对于Apk的“增量”是多少。据别人的测试\n\n> ObjectBox和Realm分别占用1-1.5MB和3-4MB（大小取决于手机架构），而作为SQL封装的Room只占用大约50KB。在方法的增量上，Room只有300多个，ObjectBox和Realm则分别是1300和2000个\n\n\n当然，如果你的数据量很大的话，我觉得还是 **ObjectBox** 更加适合你，因为就从上面的操作数据对比来看， **ObjectBox** 太牛逼了！我以后肯定也会花时间去对 **ObjectBox** 做一番研究，不过目前还是先来介绍介绍 **Room** 吧。\n\n\n# 二、Room的结构\n\n之前有说过，**Room** 是可以代替 **SQLite** 的，不过我觉得Google推出它更多的是为了搭配 **DataBinding** 使用，如果你对于 **DataBinding** 不太熟悉，可以看一看我前面的关于 **DataBinding** 的文章，这里就不再赘述了。下面就开始说说 **Room** 的结构。\n\nRoom主要分为三个部分，分别是 **Database**(数据库) 、**Entity**(实体) 、**DAO**(数据访问对象) \n\n## Database(数据库)\n\n数据库指的就是一个数据库对象，它继承于 **RoomDataBase** 这个类，并且需要用 **@DataBase** 注解，获取这个数据库对象的方法是通过调用 **Room.databaseBuilder()** 或者 **Room.inMemoryDatabaseBuilder()** ，后者表示在内存中存储数据，如果程序结束了数据也就消失了，所以一般还是使用前者。\n\n## Entity(实体)\n\n实体的概念就比较简单了，就类似于MySQL数据库里面的表，一个实体类相当于一个表，而一个实体类有多个属性，就相当于表的多个字段，这个看一看接下来关于 **Entity** 的代码便一目了然。\n\n## DAO\n\n关于 **DAO** ，抽象的概念就表示**数据访问对象**，在这里简单的解释一下就是数据操作接口，可以通过编写 **DAO接口** 对数据库进行增删改查等一系列操作。  \n> PS:这些接口可以支持RxJava的哦！\n\n下面是图片说明：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/009.png)\n\n# 三、开始使用\n\n在 **Room** 的使用过程中，也是遇到一些坑的，不过都已经解决掉了。如果你也遇到过某些问题，不妨对照一下我的接入流程，说不定就找到了问题所在。\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/008.png)\n\n## 接入Gradle\n\n为了避免之后的单元测试出现 <font color=\"#DC143C\">java.lang.RuntimeException: Method e in android.util.Log not mocked. See http://g.co/androidstudio/not-mocked for details.</font> 的错误，除了 **Room** 相关的依赖需要添加外，这里还需要再引用一下 **robolectric单元测试库** 解决问题！\n\n```\n    //room数据库\n    def room_version = \"1.1.1\"\n    implementation \"android.arch.persistence.room:runtime:$room_version\"\n    annotationProcessor \"android.arch.persistence.room:compiler:$room_version\"\n    kapt \"android.arch.persistence.room:compiler:$room_version\"      // 由于要使用Kotlin,这里使用了kapt\n    implementation \"android.arch.persistence.room:rxjava2:$room_version\"        //之后会用到rxjava，所以这里也可以有\n//    implementation \"android.arch.persistence.room:guava:$room_version\"        //由于我们不用guava，这行注释掉\n    testImplementation \"android.arch.persistence.room:testing:$room_version\" \n    \n    //robolectric测试\n    testImplementation 'org.robolectric:shadows-multidex:3.8'\n    testImplementation \"org.robolectric:robolectric:3.8\"\n    //这样就资瓷单元测试咯！\n```\n\n和我一样使用Kotlin的童鞋别忘了下面这行：\n\n```\napply plugin: 'kotlin-kapt'\n```\n还有，需要做如下更改：\n\n```\n    androidTestImplementation 'com.android.support.test:runner:1.0.2'\n\n    //更改为\n    implementation 'com.android.support.test:runner:1.0.2'\n\n```\n这点一定要改哦！不然会出现一些莫名其妙的问题\n\n\n\n\n相关库的依赖成功添加后就可以开始动手了！\n\n## 创建 Entity、Dao 与 DataBase\n\n### 创建Entity\n\n首先，创建一个 **Entity** 对象，就把它命名为 **Book** 吧\n\n\n```\n@Entity\nclass Book(@field:ColumnInfo(name = \"book_name\")\n           var bookName: String?, var author: String?, var type: String?) {\n\n    @PrimaryKey(autoGenerate = true)\n    var id: Int = 0\n}\n```\n**Book** 有三个属性，分别表示书名、作者、类型。其中有三点需要注意：\n\n- 每个 **Entity对象** 都需要使用 **@Entity** 注释声明\n- **@PrimaryKey** 注释用于声明主键，这里还添加了 autoGenerate = true，表示它是自增的\n- **@ColumnInfo** 注释用来给属性设置别名，如果 **bookName** 属性不设置别名的话，查询的时候可以通过 “**bookName**”进行查询，设置别名后就可以通过设置的“**book_name**” 进行查询了，看 **DAO接口** 便知\n\n\n\n### 创建 DAO \n\n这里，通过 **DAO接口** 来对 **Book** 这个对象进行增删改查：\n\n```\n@Dao\ninterface BookDao {\n\n    @get:Query(\"SELECT * FROM book\")\n    val all: List<Book>\n\n    @Query(\"SELECT * FROM book WHERE author LIKE :author\")\n    fun getBookByAuthor(author: String): List<Book>\n\n    @Query(\"SELECT * FROM book WHERE book_name LIKE :name\")\n    fun getBookByNamer(name: String): List<Book>\n\n    @Insert\n    fun insert(book: Book): Long?\n\n    @Insert\n    fun insert(vararg books: Book): List<Long>\n\n    @Insert\n    fun insert(books: List<Book>): List<Long>\n\n    @Update\n    fun update(book: Book): Int\n\n    @Update\n    fun update(vararg books: Book): Int\n\n    @Update\n    fun update(books: List<Book>): Int\n\n    @Delete\n    fun delete(book: Book): Int\n\n    @Delete\n    fun delete(vararg books: Book): Int\n\n    @Delete\n    fun delete(books: List<Book>): Int\n\n}\n```\n\n上面的 **DAO接口**，同样需要进行几点说明：\n\n- **DAO接口** 需要使用 **@Dao** 注释进行声明\n- **Insert** 操作可以使用 **Long** 作为返回值的类型，表示插入操作前的对象数量\n- **Update** 和 **Delete** 操作可以使用 Int 作为返回值，表示更新或者删除的行数\n- 返回类型还可以是 **void** ，如果结合 **Rxjava** 使用的话还可以是 **Completable、Single、 Maybe、Flowable**等，具体可以参见这篇文章：[Room 🔗 RxJava](https://medium.com/androiddevelopers/room-rxjava-acb0cd4f3757)(需要备好梯子，不过后续有时间的话我也会介绍一下Room搭配Rxjava的使用)\n\n**Dao接口** 编写完成后，还剩下最重要的 **DataBase**\n\n### 创建 DataBase\n\n> 由于实例化一个 **RoomDatabase** 对象的开销是比较大的，所以 **DataBase** 的使用需要遵循单例模式，只在全局创建一个实例即可。\n\n这里为了方便理解，还是使用java代码去创建一个 **BookDataBase类**，当然，转换成Kotlin只需要Shift + Alt + Ctrl + K 即可\n\n如果你使用的是饿汉式的单例模式，在Kotlin中通过object修饰可达到同样效果\n```\n@Database(entities = {Book.class}, version = 1)\npublic abstract class BookDataBase extends RoomDatabase {\n    public abstract BookDao bookDao();\n    private static BookDataBase instance;\n\n    public static BookDataBase getInstance(Context context){\n        if (instance == null){\n            synchronized (BookDataBase.class){\n                if (instance == null){\n                    instance = create(context);\n                }\n            }\n        }\n        return instance;\n    }\n\n    private static BookDataBase create(Context context) {\n        return Room.databaseBuilder( context,BookDataBase.class,\"book-db\").allowMainThreadQueries().build();\n    }\n}\n```\n\n上面的例子中有一些需要特别注意：\n\n- **@Database** 注释用于进行声明，同时还需要有相关的 **entity对象**，其中 **version** 是当前数据库的版本号，如果你对数据相关的**实体类结构**进行了更改，这里的 **version** 就需要**加一**\n- **BookDataBase** 除了继承于 **RoomDatabase** ，还需要实例出相关的 **DAO接口**\n- create()方法中的\"**book-db**\"是数据库的名字，这里随意，不过需要注意的是 **allowMainThreadQueries()** 方法，这里由于我们会用到单元测试，所以加上这行代码是为了防止 【*Cannot access database on the main thread since it may potentially lock the UI for a long period of time.*】 的报错。正式使用时，请务必去掉这行代码，因为它会让所有耗时操作运行在主线程！\n\n到这里，我们就可以先愉快的进行测试了.\n\n\n\n## 测试\n\n### 初级测试\n\n找到 **src** 下的 **test** 目录，然后可以像我这样创建一个 **RoomTest** 类进行测试\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/010.png)\n\n说到这里，可能会有童鞋尚未了解过单元测试，这时候你可以先去看看相关博客，比如这篇\n\n[Android 单元测试只看这一篇就够了](https://juejin.im/post/5b57e3fbf265da0f47352618)\n\n不过这里使用的单元测试是 Android Studio 自带的，也没有用到太复杂的东西，同时我会做一些说明，不够了解的童鞋也可以继续往下看，看完你也就了解了\n\n\n```\n@RunWith(AndroidJUnit4::class)\nclass RoomTest {\n\n    private var bookDao: BookDao? = null\n    private var bookDataBase: BookDataBase? = null\n\n    @Before\n    @Throws(Exception::class)\n    fun setUp() {\n        ShadowLog.stream = System.out      //这样方便打印日志\n        val context = InstrumentationRegistry.getTargetContext()\n        bookDataBase = BookDataBase.getInstance(context)\n        bookDao = bookDataBase?.bookDao()\n    }\n\n\n    @Test\n    fun insert() {\n        val book1 = Book(\"时间简史\", \"斯蒂芬·威廉·霍金\", \"科学\")\n        val book2 = Book(\"百年孤独\", \"西亚·马尔克斯\", \"文学\")\n        val list = bookDao?.insert(book1, book2)\n\n        assert(list?.size == 2)\n    }\n\n    @Test\n    fun query(){\n        val books = bookDao?.all\n        for (book in books?: emptyList()) {\n            Log.e(javaClass.name, \"获取的书籍数据: ${Gson().toJson(book)}\")\n        }\n    }\n\n    @After\n    @Throws(Exception::class)\n    fun cloaseDb() {\n        bookDataBase?.close()\n    }\n}\n```\n\n可以看到，这里的单元测试使用的是 **AndroidJUnit4**，通过 **@Before** 注释的方法，表示用于**相关资源的初始化**，类似于Activity的onCreate()方法；而通过 **@After** 注释的方法，则是用于**相关资源的销毁**，类似于Activity的onDestroy()方法。\n\n剩下的，通过 **@Test** 注释的方法就表示用于测试的单元，每个测试类里面可以有多个测试单元，这里目前只写了插入和查询两个单元，在 **RoomTest** 类上通过右键运行，然后看一下结果：\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/011.png)\n\n在测试代码中的 **insert()单元 ** 里，有这样一行代码：\n\n```\nassert(list.size == 2)\n```\n而测试的结果是一片绿色，就表示这个断言是正确的，list列表长度刚好为2，这里为了验证返回的list是整个数据库长度还是仅仅表示此次进行插入操作的长度，我们修改一下 insert()测试单元：\n\n```\n   @Test\n    fun insert() {\n        val book1 = Book(\"时间简史\", \"斯蒂芬·威廉·霍金\", \"科学\")\n        val book2 = Book(\"百年孤独\", \"西亚·马尔克斯\", \"文学\")\n        val list = bookDao?.insert(book1, book2)\n        assert(list?.size == 2)\n\n        val list2 = bookDao?.insert(book1, book2)\n        assert(list2?.size == 4)\n    }\n```\n\n这时候在 **insert()单元测试区域** 右键运行，就只测试这一个单元，然后结果如下：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/012.png)\n\n我们在 insert()单元 中进行了两次插入操作，所以数据库的总长度应该为 4 ，而这里第39行的代码：\n\n```\nassert(list2?.size == 4)\n```\n返回的cede 是 -1，就表示实际上每次插入操作返回的列表长度应该为插入的数量，而非数据库总量。其他操作亦是如此。\n\n在单元测试中，我们的测试并不能直接用于正式的项目中，因为数据库操作属于耗时操作，所以一定不能把这些操作放在主线程里，而最方便的线程切换，莫过于 **Rxjava** 啦！\n\n现在开始使用 **Rxjava** 进行测试吧\n\n### 结合Rxjava的测试\n\n首先，要在项目中添加 **Rxjava** 的依赖：\n\n```\n    //rxJava2+rxAndroid\n    implementation \"io.reactivex.rxjava2:rxjava:2.x.y\"\n    implementation 'io.reactivex.rxjava2:rxandroid:2.1.0'\n```\n\n在单元测试中，RxJava 如果做 **IO线程** 到 **UI线程** 的切换操作，结果是无法获取的，所以需要将这些线程进行合并，方法如下：\n\n```\n    @Before\n    @Throws(Exception::class)\n    fun setUp() {\n        val context = InstrumentationRegistry.getTargetContext()\n        bookDataBase = BookDataBase.getInstance(context)\n        bookDao = bookDataBase?.bookDao()\n        ShadowLog.stream = System.out\n\n        initRxJava2()\n    }\n    \n    private fun initRxJava2() {\n        RxJavaPlugins.reset()\n        RxJavaPlugins.setIoSchedulerHandler { Schedulers.trampoline() }\n        RxAndroidPlugins.reset()\n        RxAndroidPlugins.setMainThreadSchedulerHandler { Schedulers.trampoline() }\n    }\n```\n\n在 **@Before注解** 下的 **setUp()** 方法中进行RxJava的配置，然后我们可以把RxJava常用的线程切换写在一个方法里，方便复用：\n\n```\n    private fun<T> doWithRxJava(t: T): Observable<T>{\n        return Observable.create<T>{it.onNext(t)}\n                .subscribeOn(Schedulers.io())\n                .unsubscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n    }\n```\n\n接着，对 **insert单元** 和 **query单元** 进行修改：\n\n```\n    @Test\n    fun insert() {\n        val book1 = Book(\"时间简史\", \"斯蒂芬·威廉·霍金\", \"科学\")\n        val book2 = Book(\"百年孤独\", \"西亚·马尔克斯\", \"文学\")\n        doWithRxJava(bookDao?.insert(book1, book2))\n                .subscribe ({\n                    Log.e(\"insert长度：\" , \"${it?.size}\")\n                    assert(it?.size == 2)\n                },{\n                    Log.e(\"insert出错：\" , \"${it.stackTrace}-${it.message}\")\n                })\n    }\n\n    @Test\n    fun query(){\n        doWithRxJava(bookDao?.all)\n                .subscribe({\n                    for(book in it?: emptyList()){\n                        Log.e(javaClass.name, \"获取的书籍数据: ${Gson().toJson(book)}\")\n                        assert(it?.size == 2)\n                    }\n                },{\n                    Log.e(\"query出错：\" , \"${it.stackTrace}-${it.message}\")\n                })\n    }\n```\n\n然后看一下测试的结果：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/013.png)\n\n\n那么， **Room DataBase** 的入门指南，就写到这里啦！\n\n后续我可能会再写一篇进阶版的文章，涵盖了真实使用的场景，然后看能不能写一个简单的Demo出来，这样更方便学习吧！\n\n~~*不过我发现我现在的懒癌是越来越严重了，也不知道下一篇是什么时候*~~\n\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Room-Database/014.png)\n\n\n\n\n\n\n\n\n\n\n"},{"articleName":"DataBinding——从相识到相知（二）：互酌","createTime":"2018-10-20T21:49:47.000","lastModifiedTime":"2020-02-03T10:32:40.000","tag":"Android","summary":" 前言\n\n上一篇里，主要讲了关于Databinding的以下几点：\n\n- 接入与使用\n- 简单的数","imageAddress":"/img/data_binding.png","articleAddress":"/config/study/DataBinding——从相识到相知（二）：互酌.md","articleContent":"---\ntitle: DataBinding——从相识到相知（二）：互酌\ndate: 2018-10-20 21:49:47\nindex_img: /img/data_binding.png\ntags: Android\n---\n\n# 前言\n\n上一篇里，主要讲了关于Databinding的以下几点：\n\n- 接入与使用\n- 简单的数据绑定\n- 点击事件的绑定\n\n这一篇将会继续上一篇的步伐，对DataBinding的使用更深几分.首先依旧是从数据绑定开始\n<!--more--> \n\n> 之前所介绍的，虽然UI与数据进行了绑定，但是修改数据对象的时候并不会同时更新 **UI** .  \n现在有三种不同类型的 **observable** 类：**objects**, **fields**, 还有 **collections**.  \n当其中某个 **observable** 数据对象绑定到 **UI** 并且数据对象的属性发生更改时， UI 将自动更新，下面开始介绍.\n\n\n# Observable数据\n\n如果你的数据类只有几个属性，那么没必要去实现 **Observable** 接口来监听数据的改变，可以使用下面这些字段：\n\n- [**ObservableBoolean**](https://developer.android.google.cn/reference/android/databinding/ObservableBoolean.html)\n- [**ObservableByte**](https://developer.android.google.cn/reference/android/databinding/ObservableByte.html)\n- [**ObservableChar**](https://developer.android.google.cn/reference/android/databinding/ObservableChar.html)\n- [**ObservableShort**](https://developer.android.google.cn/reference/android/databinding/ObservableShort.html)\n- [**ObservableInt**](https://developer.android.google.cn/reference/android/databinding/ObservableInt.html)\n- [**ObservableLong**](https://developer.android.google.cn/reference/android/databinding/ObservableLong.html)\n- [**ObservableFloat**](https://developer.android.google.cn/reference/android/databinding/ObservableFloat.html)\n- [**ObservableDouble**](https://developer.android.google.cn/reference/android/databinding/ObservableDouble.html)\n- [**ObservableParcelable**](https://developer.android.google.cn/reference/android/databinding/ObservableParcelable.html)\n\n现在，我们再创建一个类\n```\nclass ObservableBean {\n    val text = ObservableField<String>()\n}\n```\n布局文件改为：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <data>\n        <variable name=\"model\" type=\"com.test.project.testdatabinding.MVP.DataBinding.Bean.ObservableBean\"/>\n    </data>\n\n    <LinearLayout\n        android:orientation=\"vertical\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n\n        <EditText\n            android:id=\"@+id/et_test\"\n            android:text=\"@={model.text}\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\" />\n\n        <TextView\n            android:id=\"@+id/tv_test\"\n            android:text=\"@{model.text}\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"/>\n        \n    </LinearLayout>\n</layout>\n```\n需要注意的是，上面的 **EditText** 的 **text** 属性使用的是 **@={}** 而 **TextView** 使用的是 **@{}** 。当你想要使用双向绑定的时候，可别忘了这个 **=** 号\n\n\n\nActivity的代码只改变了绑定对象：\n\n```\nclass DataBindingActivity<T> : AppCompatActivity() {\n\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n//        setContentView(R.layout.activity_data_binding)\n        val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)\n        bindingBinding.model = ObservableBean()\n    }\n}\n```\n效果如下：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/two/databinding-001.gif)\n\n可以看到，直接使用 **Observable** 字段去实现双向数据绑定是很轻松的，不过实际项目里面需求各不相同，要将数据都换成 **Observable** 字段还是很麻烦的，所以自定义双向数据绑定非常有必要！\n\n这时对 **ObservableBean** 进行修改：\n\n```\nclass ObservableBean : BaseObservable() {\n    @get:Bindable\n    var text: String = \"\"\n    set(value) {\n        field = value\n        notifyPropertyChanged(BR.text)\n    }\n}\n\n//相较于Kotlin写法，这里我觉得Java写法更有助于理解：\npublic  class ObservableBean extends BaseObservable {\n    private String text;\n\n    @Bindable\n    public String getText() {\n        return text;\n    }\n\n    public ObservableBean setText(String text) {\n        this.text = text;\n        notifyPropertyChanged(BR.text);\n        return this;\n    }\n}\n\n```\n修改过后的效果与之前使用 **Observable** 字段的效果一样，上面需要注意的两点：\n\n-  使用了 **@Bindable** 注解，进行绑定声明\n-  使用了 **notifyPropertyChanged()** 方法为数据刷新做准备\n\n不过在我看来，通过这种继承的方法对于我们原有的数据结构并不过友好，尤其是继承了 **BaseObservable** 类的数据类不能通过  **Gson** 去与 **Json** 相互转换。\n\n所以使用的时候，我们可以考虑通过某个中介类的方式去进行转换.\n\n\n# 布局的绑定\n\n第第一篇中，有写到Activity中如何获取自动生成的布局绑定类——xxxBinding，这种类的命名与使用数据绑定的布局文件xml有关，比如说 **activity_main.xml** 就会生成 **ActivityMainBinding** \n\n这里再详细说明一下，不同类型的布局，应该怎么获取生成的 **Binding绑定类** \n\n> 事先并不知道绑定类型的对象可以使用 **DataBindingUtil** 去创建绑定\n\n```\nval rootView = LayoutInflater.from(this).inflate(layoutId, parent, attachToParent)\nval binding: ViewDataBinding? = DataBindingUtil.bind(viewRoot)\n```\n\n## 获取带 ID 的 View对象\n\n如果使用的是Kotlin，可以直接在Activity里很方便的使用id获取View对象，不过使用DataBinding后，就有另外一种获取View对象的方式了\n\n布局里面的 Id 如下：\n\n```\n    ...\n        <EditText\n            android:id=\"@+id/et_test\"\n            android:text=\"@={model.text}\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\" />\n\n    ...\n```\n\n通过 Id 获取 EditText 的方法如下：\n\n```\n        ...\n        super.onCreate(savedInstanceState)\n        val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)\n        bindingBinding.model = ObservableBean()\n        val editText = bindingBinding.root.rootView.findViewById<EditText>(R.id.et_test)\n```\n\n\n> **立即绑定**  \n>\n> 当变量或可观察对象发生更改时，绑定会在下一帧之前更改。 不过有的时候需要立刻执行绑定.  \n>\n> 若要强制执行，可以使用 **executePendingBindings()** 方法。\n\n## 高级绑定\n\n有时候，特定的绑定类是未知的.  \n\n例如，针对任意布局操作的 **RecyclerView.Adapter** 不知道特定的绑定类.它仍然必须在调用 **onBindViewHolder()** 方法时分配绑定值.\n\n在 **RecyclerView** 的  **onBindViewHolder()** 方法里，可以这样写：\n\n```\noverride fun onBindViewHolder(holder: BindingHolder, position: Int) {\n    item: T = mItems.get(position)\n    holder.binding.setVariable(BR.item, item);\n    holder.binding.executePendingBindings();\n}\n```\n\n## 使用@BindingAdapter自定义绑定逻辑\n\nDataBinding为我们提供了一种可以对绑定逻辑进行自定义的方法，比如说我想在xml中对一个ImageView控件加载图片，并且是使用的Glide加载框架，这时候可以这样：\n\n```\n//随便创建一个类，然后在类中定义如下方法\n@BindingAdapter(\"imageUrl\")\nfun loadImage(view: ImageView, url: String) {\n    GlideApp.with(view.getContext())\n   .load(url)\n   .fitCenter()\n   .into(view);\n}\n```\n使用的时候编译器会自动生成对应属性：\n\n```\n<ImageView \napp:imageUrl=\"@{model.imageUrl}\"  />\n```\n使用 **@BindAdapter** 几乎可以完成你想要的各种逻辑，不过我觉得，只有那种使用率特别高的代码，才最适合这个属性.\n\n## 使用@BindingConversion完成转换功能\n\n在某些情况下，特定类型之间需要自定义转换。 例如，视图的android:background属性需要Drawable，但指定的颜色值是整数。 \n\n官方例子中，转换功能的具体用法如下：\n\n```\n@BindingConversion\nfun convertColorToDrawable(color: Int) = ColorDrawable(color)\n```\n使用的时候可以这样：\n\n```\n<View\n   android:background=\"@{isError ? @drawable/error : @color/white}\"\n   android:layout_width=\"wrap_content\"\n   android:layout_height=\"wrap_content\"/>\n```\n\n\n\n# 暂歇\n\n本篇关于DataBindin的介绍也就到此结束，不过DataBinding的使用还没有到头，下一篇将会侧重实际上的操作以及DataBinding还可以为我们带来哪些便捷.\n\n\n\n---\n\n# 未完待续\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"articleName":"DataBinding——从路人到好友（一）：初遇","createTime":"2018-10-17T21:49:47.000","lastModifiedTime":"2020-02-03T10:16:26.000","tag":"Android","summary":" 杂谈\n\n\n> 在编程领域，对于一名初学者而言，最开始的进阶方式都是不断重复的练习，然后在练习中遇","imageAddress":"/img/data_binding.png","articleAddress":"/config/study/DataBinding——从路人到好友（一）：初遇.md","articleContent":"---\ntitle: DataBinding——从路人到好友（一）：初遇\ndate: 2018-10-17 21:49:47\nindex_img: /img/data_binding.png\ntags: Android\n---\n\n# 杂谈\n\n\n> 在编程领域，对于一名初学者而言，最开始的进阶方式都是不断重复的练习，然后在练习中遇到各种困难，同时也在这个过程里积累了不少的经验。\n>\n> 一般情况下，我们获取的经验可以有效的减少我们的失误，也可以为我们预防掉许多“隐藏”的Bug。\n> \n> 但是，随着我们能力的提升，我们逐渐的对于那些重复性非常高、而且意义并不大的代码产生了厌倦感。首当其冲的就是像 **findViewById** 这样的代码！\n\n大量的 **findViewById** 与全局变量想必是许多初学者都会经历的阶段，不过学的东西越多，对于这类代码的接受力也就越低。所以许多人选择用了 **ButterKnife** 去解决这个问题。\n\n然鹅当 **Kotlin** 出现后，**ButterKnife** 也可以随之抛弃了，这时候 **DataBinding** 的用处却和 **Kotlin** 并不冲突，相反二者结合使用，反而会让你有意想不到的、久违的、可圈可点的、眼前一亮的、拍手称赞的体验！\n\n\n# 使用\n\n\n使用 **Data-Binding** ，首先需要在 **app moudle** 下的 **build.gradle** 中添加：\n\n```\nandroid {\n    ...\n    dataBinding {\n        enabled = true\n    }\n    ...\n}\n```\n\n然后就可以正常使用了，不过需要注意，最低支持的Android版本是4.0（反正几乎没有比这更低的android设备了），gradle插件版本是1.5.0 （都2018年了，android开发者们肯定不能用比这更低的版本了吧！）\n\n\n接下来，举个最简单的栗子，我们创建一个 **Cartoon** 类：\n\n```\nclass Cartoon(var name:String = \"JOJO的奇妙冒险\" , var series :String = \"黄金之风\",\n              var leader : String = \"乔鲁诺·乔巴纳\", var feature : String = \"黄金体验\") {\n}\n```\n然后新建一个Activity，在这个Activity的xml中的根布局下，通过Alt+Enter快捷键创建databinding的布局，同时，导入 **Cartoon** 类：\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-001.png)\n\n这时候，编译器会自动根据这个布局生成相应的绑定类，这里会生成一个 **ActivityDataBindingBinding** 的类 ，暂时先不用管，我们继续在xml上工作，修改一下布局样式：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-002.png)\n\n然后，在对应的Activity内对生成的 **ActivityDataBindingBinding** 类进行操作：\n\n```\nclass DataBindingActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n//        setContentView(R.layout.activity_data_binding)\n        val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)\n        bindingBinding.cartoon = Cartoon()\n    }\n}\n```\n\n由于Kotlin创建的Cartoon实体类已经给每个字段都赋予了初始值，这里不用再进行赋值，然后看一下效果：\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-003.png)\n\n> 如果你使用的是 items 去进行的绑定，例如Fragment、RecyclerView的adapter，可以使用 inflate() 的方法去绑定或者 DataBindingUtil 类，就像下面这样\n\n```\nval listItemBinding = ListItemBinding.inflate(layoutInflater, viewGroup, false)\n// or\nval listItemBinding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false)\n```\n\n如果这时候你想使用字符串拼接，可以在 **string.xml** 中创建，比如：\n\n```\n    <string name=\"cartoon_name\">动漫名:%s</string>\n    <string name=\"cartoon_series\">系列:%s</string>\n    <string name=\"cartoon_leader\">主角:</string>\n    <string name=\"cartoon_bodyDouble\">替身:</string>\n```\n使用的时候可以是这样：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <data>\n        <variable name=\"cartoon\" type=\"com.test.project.testdatabinding.DataBinding.Cartoon\"/>\n    </data>\n\n    <LinearLayout\n        android:orientation=\"vertical\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n        <TextView\n            android:layout_gravity=\"center\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{@string/cartoon_name(cartoon.name)}\"/>\n        <TextView\n            android:layout_gravity=\"center\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{@string/cartoon_series(cartoon.series)}\"/>\n        <TextView\n            android:layout_gravity=\"center\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{@string/cartoon_leader + cartoon.leader}\"/>\n        <TextView\n            android:layout_gravity=\"center\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{@string/cartoon_bodyDouble + cartoon.feature}\"/>\n\n    </LinearLayout>\n</layout>\n```\n效果如下：\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-004.png)\n\n至此，我们完成了与DataBinding的初次接触！\n\n可以看到，相较于往常的通过findViewById去获取控件实例，然后给控件设置数据的方法，这样显然去掉了Activity内许多不必要的代码。\n\n不过以上只是比较简单的DataBinding用法，下面将会介绍DataBinding的其他功能，这样才能应更复杂的需求。\n\n\n## 集合的使用\n\n\n```\n<data>\n    <import type=\"android.util.SparseArray\"/>\n    <import type=\"java.util.Map\"/>\n    <import type=\"java.util.List\"/>\n    <variable name=\"list\" type=\"List<String>\"/>\n    <variable name=\"sparse\" type=\"SparseArray<String>\"/>\n    <variable name=\"map\" type=\"Map<String, String>\"/>\n    <variable name=\"index\" type=\"int\"/>\n    <variable name=\"key\" type=\"String\"/>\n</data>\n…\nandroid:text=\"@{list[index]}\"\n…\nandroid:text=\"@{sparse[index]}\"\n…\nandroid:text=\"@{map[key]}\"  //这里也可以使用 @{map.key}代替\n```\n\n## 点击事件\n\n点击事件也是可以在xml中绑定的，在 DataBindingActivity 中添加如下方法：\n\n```\n    fun doClick(view: View){\n        Toast.makeText(this, \"点击测试\", Toast.LENGTH_SHORT).show()\n    }\n```\n不要忘了在括号中传入View\n\n然后再xml中写一个button的点击事件\n```\n <Button\n            android:text=\"DataBinding-点击测试\"\n            android:onClick=\"doClick\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\" />\n```\n如果想通过点击事件传入参数的话，可以通过下面这种方法：\n\n\n```\n<variable name=\"handler\" type=\"com.test.project.testdatabinding.DataBinding.DataBindingActivity\"/>\n\n\n<Button\n            android:text=\"DataBinding-点击测试\"\n            android:onClick=\"@{() -> handler.doClick(cartoon.name)}\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\" />\n```\n从xml中导入 DataBindingActivity 后，再修改代码：\n\n```\nclass DataBindingActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n//        setContentView(R.layout.activity_data_binding)\n        val bindingBinding : ActivityDataBindingBinding = DataBindingUtil.setContentView(this, R.layout.activity_data_binding)\n        bindingBinding.cartoon = Cartoon()\n        bindingBinding.handler = this\n    }\n\n    fun doClick(message: String){\n        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()\n    }\n}\n```\n点击效果如下：\n\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/DataBinding/one/databinding-005.png)\n\n如果有更加复杂的点击事件，可以参考官介绍中的，如带View参数的：\n```\nclass Presenter {\n    fun onSaveClick(view: View, task: Task){}\n}\n\n\nandroid:onClick=\"@{(theView) -> presenter.onSaveClick(theView, task)}\"\n```\n\n## import 与 include\n\n### import\n\n在xml中，可以通过导入一些工具类进行简单地操作，比如说导入View类：\n\n```\n<data>\n    <import type=\"android.view.View\"/>\n</data>\n```\n这样你就可以直接在xml中使用它的一些静态方法或者变量,官方的例子中简单地用法如下：\n\n```\n<TextView\n   android:text=\"@{user.lastName}\"\n   android:layout_width=\"wrap_content\"\n   android:layout_height=\"wrap_content\"\n   android:visibility=\"@{user.isAdult ? View.VISIBLE : View.GONE}\"/>\n```\n不过我觉得xml中不适合做太多逻辑判断的操作，所以使用的时候应该考虑一下某些操作是否真的合适\n\n\n### include\n\n如果你有在xml中使用到 include ，通过下面例子中的方法就行绑定：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:bind=\"http://schemas.android.com/apk/res-auto\">\n    <data>\n        <variable name=\"cartoon\" type=\"com.test.project.testdatabinding.DataBinding.Cartoon\"/>\n    </data>\n\n    <LinearLayout\n        android:orientation=\"vertical\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n        \n       <include layout=\"@layout/layout_test\"\n           bind:cartoon=\"@{cartoon}\"/>\n\n    </LinearLayout>\n</layout>\n```\nlayout_test 布局：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <data>\n        <variable name=\"cartoon\" type=\"com.test.project.testdatabinding.DataBinding.Cartoon\"/>\n    </data>\n\n    <android.support.constraint.ConstraintLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n\n        <TextView\n            android:text=\"@{cartoon.name}\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\" />\n\n    </android.support.constraint.ConstraintLayout>\n</layout>\n```\n注意，要使用 bind 属性，可别忘了下面的这行代码：\n\n```\nxmlns:bind=\"http://schemas.android.com/apk/res-auto\"\n```\n\n# 暂歇\n\n出于篇幅考虑，关于 **DataBinding** 的使用，暂且就讲到这里，关于它更详尽的用法，后续再作介绍。\n\n\n\n---\n\n# 未完待续\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"articleName":"手把手教你android端微信支付接入","createTime":"2018-10-08T21:49:47.000","lastModifiedTime":"2020-02-03T10:29:42.000","tag":"Android","summary":" Android端接入微信支付，蛮简单的\n\n\n 一、添加gradle依赖：\n\n在app m","imageAddress":"/img/wechat_pay.png","articleAddress":"/config/study/手把手教你android端微信支付接入.md","articleContent":"---\ntitle: 手把手教你android端微信支付接入\ndate: 2018-10-08 21:49:47\nindex_img: /img/wechat_pay.png\ntags: Android\n---\n\n## Android端接入微信支付，蛮简单的\n\n\n### 一、添加gradle依赖：\n\n在app module目录下的build.gralde中添加\n\n```\ndependencies {\n    //微信SDK接入\n    implementation 'com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+'\n}\n```\ngralde构建完成之后，再做下一步的操作。\n\n### 二、在AndroidManifest.xml中添加相关权限：\n\n```\n    <!--微信支付权限-->\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\"/>\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n\n### 三、创建wxapi目录，并创建WXPayEntryActivity\n\n在你的package目录下，创建**wxapi**目录，比如说我使用的demo项目，**wxapi**就在目录**net.sourceforge.simcpux**目录下\n\n同时，在**wxapi**目录下创建**WXPayEntryActivity**\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-001.png)\n\n**WXPayEntryActivity**实现**IWXAPIEventHandler**接口，这个Activity页面就是支付结果的回调页面，下面是它最简单地实现：\n```\npublic class WXPayEntryActivity extends Activity implements IWXAPIEventHandler{\n\t\n\tprivate static final String TAG = \"MicroMsg.SDKSample.WXPayEntryActivity\";\n\t\n    private IWXAPI api;\n\t\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.pay_result);\n        \n    \tapi = WXAPIFactory.createWXAPI(this, \"你的appid\");\n        api.handleIntent(getIntent(), this);\n    }\n\n\t@Override\n\tprotected void onNewIntent(Intent intent) {\n\t\tsuper.onNewIntent(intent);\n\t\tsetIntent(intent);\n        api.handleIntent(intent, this);\n\t}\n\n\t@Override\n\tpublic void onReq(BaseReq req) {\n\t}\n\n\t@Override\n\tpublic void onResp(BaseResp resp) {\n\t\tLog.d(TAG, \"onPayFinish, errCode = \" + resp.errCode);\n\n\t\tif (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) {\n\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\t\tbuilder.setTitle(\"支付结果\");\n\t\t\tbuilder.setMessage(getString(R.string.pay_result_callback_msg, String.valueOf(resp.errCode)));\n\t\t\tbuilder.show();\n\t\t}\n\t}\n}\n```\n同时，别忘了在**AndroidManifest.xml**中声名**WXPayEntryActivity**\n\n\n```\n        <activity\n            android:name=\".wxapi.WXPayEntryActivity\"\n            android:exported=\"true\"\n            android:launchMode=\"singleTop\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\"/>\n                <category android:name=\"android.intent.category.DEFAULT\"/>\n                <data android:scheme=\"你的appid\"/>\n            </intent-filter>\n\n        </activity>\n```\n\n当这些准备工作都做好之后，就可以准备使用了。\n\n### 四、使用\n\n当你从服务端获取到订单的相关信息后，就可以调用支付接口了：\n```\n                IWXAPI api = WXAPIFactory.createWXAPI(context, null);\n                api.registerApp(IntentKey.WX_APP_ID);\n                PayReq req = new PayReq();\n                req.appId\t\t\t= \"wx8888888888888888\";//你的微信appid\n                req.partnerId\t\t= \"1900000109\";//商户号\n                req.prepayId\t\t= \"WX1217752501201407033233368018\";//预支付交易会话ID\n                req.nonceStr\t\t= \"5K8264ILTKCH16CQ2502SI8ZNMTM67VS\";//随机字符串\n                req.timeStamp\t\t= \"1412000000\";//时间戳\n                req.packageValue\t= \"Sign=WXPay\";扩展字段,这里固定填写Sign=WXPay\n                req.sign\t\t\t= \"C380BEC2BFD727A4B6845133519F3AD6\";//签名\n//\t\t\t\treq.extData\t\t\t= \"app data\"; // optional\n                // 在支付之前，如果应用没有注册到微信，应该先调用IWXMsg.registerApp将应用注册到微信\n                api.sendReq(req);\n```\n\n这里需要注意的是，上面的这些信息，都应该从服务器去获取，比如说随机字符串之类的长短也不一定和上面例子中的一致。具体是什么，得看你们的后端给的是什么。\n\n不出意外的话，通过上面接口的调用，你就可以正常使用微信提供的APP支付了。\n\n是不是非常简单？！\n\n***然鹅。。。***\n\n事情哪儿有这么顺利，到了真正使用的时候，遇到的问题可不少，下面会列举出遇到过的问题，然后说明解决办法。\n\n\n## Android端接入微信支付，坑蛮多的\n\n**微信支付app的接入，要我来说，对初次尝试的人非常不友好**\n\n一般情况下，开发者使用新的工具都需要先看一看它的说明文档，如果说明文档写的够好，直接用就是了；如果文档介绍的不够全面，还需要有Demo提供参考。微信的App支付就属于后者。\n下面是它的接入文档页面：\n\n[Android接入指南](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=1417751808&token=&lang=zh_CN)（还有其他相关信息也可以通过这个页面接入）\n\n由于仅仅靠着文档的说明不足以让我掌握对微信支付的使用，所以自然而然的，Demo就成了初次接触微信支付者的学习教材啦！\n\n[Demo下载](https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=11_1)\n\n当你接入Demo后，一系列的问题将会接踵而至，下面来看一看具体是什么问题\n\n### 接入Demo\n\n将下载后的Demo按照Import moudule的方式接入到某个项目中：\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-002.png)\n\n然后选中这个项目，进行编译：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-003.png)\n\n接下来，编译器就开始报错了，找到报错的位置，发现是如下问题：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-004.png)\n\n**到这里开始，我就要吐槽了**\n\n这种问题一看就是找不到包了，于是我们看一下这个项目中的build.gralde中的依赖，如下\n```\ndependencies {\n    compile files('libs/libammsdk.jar')\n    compile files('libs/wechat-sdk-android-with-mta-1.0.2.jar')\n}\n\n```\n很显然，是导入的本地jar包，为了方便起见，我们将这里的依赖修改成之前配置时的：\n\n```\ndependencies {\n    //微信SDK接入\n    implementation 'com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+'\n}\n```\n同时，我们还可以发现，重新构建完项目后，上面的问题并没有解决。\n\n这时候我们在Android studio的中的**External Libraries**去看一看新构建的库:\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-005.png)\n\n可以看到，正确的引用路径应该是把**sdk**换成**opensdk**\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-006.png)\n\n当你将所有的路径都修改过来后，还会有如下问题：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-007.png)\n\n将上面的 **imgObj.imageUrl = url** 修改为：\n\n```\nimgObj.setImagePath(url);\n```\n这个错误出现的地方有两处吧，当你把这些错误都解决后，再次进行编译，就可以正常运行啦！\n\nDemo运行后的界面是这样的：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-008.png)\n\n到了这里，基本上就可以进行测试了，剩下的东西无需再多说，过程差不多和上面直接接入的流程一样，不过要demo里面的更加详细，只需多多观摩即可。\n\n那么，最后还是说一下需要注意的点吧。\n\n### 注意事项\n\n在微信开放平台上面设置app相关参数的时候，需要**应用包名**以及**应用签名**\n\n![image](https://pay.weixin.qq.com/wiki/doc/api/img/chapter8_5_2.png)\n\n获取应用签名的工具地址是：[签名工具下载地址](https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/Gen_Signature_Android.apk)\n\n> 这里又要吐槽一下，签名工具就是一个apk，装到手机上后，输入包名，然后生成签名，最关键的是这个签名无法复制，使用下来就一个感受，不方便啊！！！！\n\n签名工具里面输入的包名就是之前提到过的，可以直接在Androidmanifest.xml中复制。\n\n**但是**\n\n    尽管包名一样，release版的项目和debug版的项目最后生成的签名都是不一样的，这点很重要！\n    \n**所以如果你是用的debug进行测试，那么网站里面的签名一定要填写debug版下获取到的签名，正式发布的时候，要把它换成release版的！如果签名不一致，你是无法通过那个“-1”返回值获取到任何有效的错误信息的!切记！**\n\n\n<font face=\"STCAIYUN\">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~那么</font>\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/wxpay-009.png)"},{"articleName":"Kotlin学习笔记（第六章）","createTime":"2018-10-05T21:49:47.000","lastModifiedTime":"2020-02-03T10:38:44.000","tag":"Kotlin","summary":" 1.可空类型\n\n问号可以加在任何类型的后面来表示这个类型的变量可以存储 null 引用 ： ","imageAddress":"/img/kotlin_5.png","articleAddress":"/config/study/Kotlin学习笔记（第六章）.md","articleContent":"---\ntitle: Kotlin笔记(五):基础篇latest\ndate: 2018-10-05 21:49:47\nindex_img: /img/kotlin_5.png\ntags: Kotlin\n---\n\n### 1.可空类型\n\n问号可以加在任何类型的后面来表示这个类型的变量可以存储 null 引用 ： String?、 Int?、 MyCustomType? ，等等\n\n一旦你有一个可空类型的值，能对它进行的操作也会受到限制。例如，不能再调用它的方法 \n```\n>> fun strLenSafe(s: String?) = s.length() \nERROR: only safe (?.) or non null asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String?\n```\n也不能把它赋值给非空类型的变量 ：\n```\n>> val x: String? = null \n>> var y: String = x \nERROR: Type mismatch: inferred type is String? but String was expected \n```\n也不能把可空类型的值传给拥有非空类型参数的函数 ：\n```\n>> strLen(x) \nERROR: Type mismatch: inferred type is String? but String was expected \n```\n那么你可以对它做什么呢？最重要的操作就是和 null 进行比较。 而且一旦你 进行了比较操作，编译器就会记住，并且在这次比较发生的作用域内把这个值当作非空来对待\n\n\n### 2.安全调用运算符：\"?.\"\n\n> Kotlin的弹药库中最有效的一种工具就是安全调用运算符：?.，它允许你把一 次null检查和一次方法调用合并成一个操作。\n\n例如，表达式 s?.toUpperCase() 等同于下面这种烦琐的写法：if(s!=null) s.toUpperCase() else null。 \n\n### 3.Elvis运算符：\"?:\" \n\nKotlin 有方便的运算符来提供代替null的默认值。它被称作**Elvis运算符**（或者 null合并运算符，如果你喜欢听起来更严肃的名称）。下面展示了它是如何使用的：\n```\nfun foo(s: String?) {\n    val t: String= s?:\"\"\n}\n```\n*Elvis 运算符接收两个运算数，如果第一个运算数不为null，运算结果就是第 一个运算数；如果第一个运算数为null，运算结果就是第二个运算数。*\n\n### 4.安全转换：\"as?\"\n\n> as? 运算符尝试把值转换成指定的类型，如果值不是合适的类型就返回 null\n\n一种常见的模式是把安全转换和 Elvis 运算符结合使用。例如，实现 equals 方法的时候这样的用法非常方便。\n\n\n```\nclass Person(val firstNarne: String, val lastNarne: String){\n    override fun equals(o: Any?): Boolean {\n        val otherPerson = o as? Person?: return false\n        return otherPerson.firstNarne == firstNarne && otherPerson.lastNarne == lastNarne \n    }\n    \n    override fun hashCode(): Int = firstNarne.hashCode() * 37 + lastNarne.hashCode() \n}\n\n\n>> val pl = Person ( \"Drnitry\",\"Jernerov\") \n>> val p2 = Person ( \"Drnitry\",\"Jernerov\") \n>> println (pl == p2) \ntrue\n>> println(pl.equals(42)) \nfalse \n```\n\n### 5.非空断言：\"!!\"\n\n> 非空断言是 Kotlin 提供给你的最简单直率的处理可空类型值的工具。它使用双感叹号表示，可以把任何值转换成非空类型。如果对 null 值做非空断言，则会抛出异常。\n\n某些问题适合用非空断言来解决。当你在一个函数中检查一个值是否为null，而在另一个函数中使用这个值时，这种情况下编译器无法识别这种用法是否安全。如果你确信这样的检查一定在其他某个函数中存在，你可能不想在使用这个值之前重复检查，这时你就可以使用非空断言。\n\n 当你使用 !! 并且它的结果是异常时， 异常调用械的跟踪信息只表明异常发生在哪一行代码，而不会表明异常发生在哪一个表达 式。 为了让跟踪信息更清晰精确地表示哪个值为 null，最好避免在同一行中使用多个!!断言\n\n### 6.\"let\"函数\n\n> let 函数让处理可空表达式变得更容易。 和安全调用运算符一起，它允许你对表达式求值，检查求值结果是否为 null，并把结果保存为一个变量。 所有这些动作都在同一个简洁的表达式中。 \n\n下面举个栗子：\n\n```\nfun sendEmailTo(email: String) { /* ... */ } \n```\n不能把可空类型的值传上面给这个函数：\n\n\n```\n>> val email: String? = ...\n>> sendEmailTo(email) \nERROR: Type mismatch: inferred type is String? but String was expected \n```\n必须显式地检查这个值不为 null:\n\n```\nif (email != null) sendEmailTo(email)\n```\n如果使用了let函数，会是下面这样子的：\n\n```\nemail?.let { email -> sendEmailTo(email) } \n```\n**let** 函数只在 email 的值非空时才被调用，所以你就能在 lambda 中把 email 当作非空的实参使用。\n使用自动生成的名字 it 这种简明语法之后，上面的代码就更短了 ： \n```\n email?.let{ sendEmailTo(it) ｝ \n```\n\n### 7.延迟初始化的属性\n\nKotlin 通常要求你在构造方法中初始化所有属性，如果某个属性是 非空类型，你就必须提供非空的初始化值。否则，你就必须使用可空类型。否则， 你就必须使用可空类型。如果你这样做，该属性的每一次访问都需要 null 检查或者 !! 运算符。\n```\nclass MyService {\n    fun performAction() : String = \"foo\"\n}\n\nclass MyTest{\n    private var myService: MyService? = null \n    \n    @Before fun setUp(){\n        myService = MyService() \n    }\n    \n    \n    @Test fun testAction(){\n        //必须注意可空性：要么 用!!， 要么用?.\n        Assert.assertEquals( \"foo\" ， myService!!.performAction() ) \n    }\n}\n```\n这段代码很难看，尤其是你要反复使用这个属性的时候。 \n为了解决这个问题， 使用 **lateinit** 修饰符来完成这样的声明。\n```\nclass MyService {\n    fun performAction() : String = \"foo\"\n}\n\nclass MyTest{\n    //声明一个不需要初始化 器的非空类型的属性\n    private lateinit var myService: MyService\n    \n    @Before fun setUp(){\n        myService = MyService() \n    }\n    \n    @Test fun testAction(){\n        //不需要 null 检查直接访问属性\n        Assert.assertEquals( \"foo\" ， myService!!.performAction() ) \n    }\n}\n```\n*注意， 延迟初始化的属性都是 var，因为需要在构造方法外修改它的值*\n\n### 8.\"Any\"和\"Any?\"：根类型\n\n> 和 Object 作为 Java 类层级结构的根差不多， **Any** 类型是 Kotlin 所有非空类型的超类型（非空类型的根）。\n>\n> 但是在 Java 中， Object 只是所有引用类型的超类 型（引用类型的根），而基本数据类型并不是类层级结构的一部分。\n>\n> 这意味着当你 需要 Object 的时候，不得不使用像 java.lang.Integer 这样的包装类型来表示基本数据类型的值。 **而在 Kotlin 中， Any 是所有类型的超类型（所有类型的根）**， 包括像 Int 这样的基本数据类型。 \n\n和 Java 一样，把基本数据类型的值赋给 **Any** 类型的变量时会自动装箱：\n\n```\nval answer: Any = 42 \n```\n*注意 **Any** 是非空类型，所以 **Any** 类型的变量不可以持有 null 值*\n\n### 9.Unit 类型 ： Kotlin 的\"void\"\n\nKotlin 中的 **Unit** 类型完成了 Java 中的 void 一样的功能。当函数没什么有意思的结果要返回时，它可以用作函数的返回类型：\n```\nfun f () : Unit { . . . } \n```\n语法上，这和写一个带有代码块体但不带类型声明的函数没有什么不同：\n\n```\nfun f () { .. }         //缩写版\n```\n> Unit 是一个完备的类型，可以作为类型参数，而 void 却不行。\n\n在函数式编程语言中， Unit 这个名字习惯上被用来表示“只有一个实例”，这正是 Kotlin 的 Unit 和 Java 的 void 的区别。\n\n### 10.Nothing类型：“这个函数永不返回”\n\n对某些 Kotlin 函数来说，\"返回类型\"的概念没有任何意义，因为它们从来不会成功地结束\n,Kotlin 使用一种特殊的返回类型 Nothing 来表示：\n\n```\nfun fail(message: String): Nothing { \n    throw IllegalStateException (message)\n}\n\n>> fail (\"Error occurred\")\njava.lang.IllegalStateException: Error occurred \n```\nNothing 类型没有任何值， 只有被当作函数返回值使用，或者被当作泛型函数 返回值的类型参数使用才会有意义。在其他所有情况下，声明一个不能存储任何值 的变量没有任何意义。 \n\n\n### 11.可空性和集合\n\n遍历一个包含可空值的集合并过滤掉 null 是一个非常常见的操作，因此 Kotlin 提供了一个标准库函数 **filterNotNull** 来完成它。 \n\n### 12.只读集合与可变集合 \n\nKotlin 的集合设计和 Java 不同的另一项重要特质是，它把访问集合数据的接口和修改集合数据的接口分开了。这种区别存在于最基础的使用集合的接口之中:kotlin.collections.Collection。\n\n使用 kotlin.collections.MutableCollection 接口可以修改集合中的数据。它继承了普通的 kotlin.collections.Collection 接口,还提供了方法来添加和移除元素、清空集合等。 \n\n一般的规则是在代码的任何地方都应该使用只读接口，只在代码需要修改集合的地方使用可变接口的变体\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"articleName":"Kotlin学习笔记（第五章）","createTime":"2018-10-03T21:49:47.000","lastModifiedTime":"2020-02-03T10:40:55.000","tag":"Kotlin","summary":" 1.成员引用\r\n\r\nKotlin和Java8一样，如果把函数转换成一个值，你就可以传递它。 ","imageAddress":"/img/kotlin_4.png","articleAddress":"/config/study/Kotlin学习笔记（第五章）.md","articleContent":"---\ntitle: Kotlin笔记(四):基础篇most plus\ndate: 2018-10-03 21:49:47\nindex_img: /img/kotlin_4.png\ntags: Kotlin\n---\n\n\n### 1.成员引用\r\n\r\nKotlin和Java8一样，如果把函数转换成一个值，你就可以传递它。  \r\n> 使用:: 运算符来转换 ：\r\n\r\n```\r\nval getAge = Person::age \r\n```\r\n这种表达式称为成员引用，它提供了简明语法，来创建一个调用单个方法或者 访问单个属性的函数值。双冒号把类名称与你要引用的成员（一个方法或者一个属性）名称隔开\r\n\r\n### 2.集合的函数式API\r\n\r\n**filter** 函数遍历集合并选出应用给定 **lambda** 后会返回 **true** 的那些元素：\r\n\r\n```\r\n>> val list= listOf(l, 2, 3, 4) \r\n>> println(list.filter{it % 2 == 0}) \r\n```\r\n\r\n**filter** 函数可以从集合中移除你不想要的元素，但是它并不会改变这些元素。 元素的变换是 **map** 的用武之地。 \r\n\r\n**map** 函数对集合中的每一个元素应用给定的函数并把结果收集到一个新集合。可以把数字列表变换成它们平方的列表，比如：\r\n\r\n```\r\n>> val list= listOf(l, 2, 3, 4) \r\n>> println(list.map { it * it }\r\n{1, 4, 9, 16}\r\n```\r\n\r\n### 3.\"all\"\"any\"\"count\"和\"find\"：对集合应用判断式\r\n\r\n检查集合中的所有元素是否都符合某个条件（或者它的变种，是否存在符合的元素）。Kotlin中，它们是通过 **all** 和 **any** 函数表达的。 \r\n\r\n\r\n```\r\nval canBeinClub27 = { p: Person - > p.age <= 27 } \r\n```\r\n> 如果你对是否所有元素都满足判断式感兴趣，应该使用 **all** 函数：\r\n\r\n```\r\n>> val people= listOf(Person (\"Alice\", 27), Person(\"Bob\", 31))\r\n>> println( people.all(canBeinClub27) ) \r\nfalse\r\n```\r\n> 如果你需要检查集合中是否至少存在一个匹配的元素，那就用 **any** :\r\n\r\n```\r\n>> println(people any(canBeinClub27)) \r\ntrue \r\n```\r\n> 如果你想知道有多少个元素满足了判断式，使用 **count** : \r\n\r\n```\r\n>> val people= listOf(Person(\"Alice\", 27) , Person (\"Bob\", 31)) \r\n>> println(people.count(canBeinClub27))\r\n1\r\n```\r\n> 要找到一个满足判断式的元素，使用 **find** 函数 ：\r\n\r\n```\r\n>> val people= listOf(Person(\"Alice\"， 27) , Person(\"Bob\", 31)) \r\n>> println(people.find(canBeinClub27)) \r\nPerson(name=Alice, age=27) \r\n```\r\n### 4.groupBy ：把列表转换成分组的 map\r\n\r\n假设你需要把所有元素按照不同的特征划分成不同的分组。例如，你想把人按年龄分组，相同年龄的人放在一组。把这个特征直接当作参数传递十分方便。**groupBy** 函数可以帮你做到这一点：\r\n\r\n```\r\n>> val people= listOf(Person(\"Alice\", 31), Person(\"Bob\", 29), Person (\"Carol\", 31))\r\n>> println(people.groupBy {it.age})\r\n```\r\n这次操作的结果是一个 **map**，是元素分组依据的键（这个例子中是age）和元素分组（persons）之间的映射\r\n\r\n### 5.flatMap 和 flatten ：处理嵌套集合中的元素 \r\n\r\n假设你有一堆藏书，使用 Book 类表示 ：\r\n\r\n```\r\nclass Book (val title: String, val authors: List<String>) \r\n```\r\n每本书都可能有一个或者多个作者，可以统计出图书馆中的所有作者的 set : \r\n\r\n```\r\nbooks.flatMap { it.authors } toSet() \r\n```\r\n**flatMap** 函数做了两件事情：首先根据作为实参给定的函数对集合中的每个元素做变换（或者说映射），然后把多个列表合并（或者说平铺）成一个列表。 \r\n\r\n> **注意，如果你不需要做任何变换，只是需要平铺一个集合，可以使用flatten函数：listOfLists.flatten() 。**\r\n\r\nKotlin 标准库参考文档有说明，**filter** 和 **map** 都会返回一个列表。这意味着元素过多的时候，（链式）调用就会变得十分低效。为了提高效率，可以把操作变成使用序列，而不是直接使用集合，下面是对比的例子\r\n\r\n\r\n```\r\npeople.map(Person: :name) .filter { it.startsWith(\"A\")｝\r\n```\r\n转化为：\r\n```\r\npeople.asSequence()\r\n    .map (Person: : name)\r\n    .filter{it.startsWith(\"A\")}\r\n    .tolist\r\n```\r\nKotlin惰性集合操作的入口就是 **Sequence** 接口。这个接口表示的就是一个可以逐个列举元素的元素序列。 \r\n\r\n可以调用扩展函数 **asSequence** 把任意集合转换成序列，调用  **toList** 来做反向的转换。 \r\n\r\n\r\n### 6.使用Java函数式接口\r\n\r\n **OnClickListener** 接口只有一个抽象方法。这种接口被称为 **函数式接口**，或者 **SAM接口**，**SAM** 代表抽象方法。JavaAPI中随处可见像**Runnable**和**Callable**这样的函数式接口，以及支持它们\r\n 的方法。 Kotlin 允许你在调用接收函数式接口作为参数的方法时使用 **lambda**，来保证你的 Kotlin代码既整洁又符合习惯。\r\n\r\n可以把 **lambda** 传给任何期望函数式接口的方法。例如，下面这个方法，它有一个 **Runnable** 类型的参数：\r\n\r\n```\r\n/* Java */ \r\nvoid postponeComputation(int delay, Runnable computation); \r\n```\r\n下面是显式地创建一个实现了 **Runnable** 的匿名对象的例子：\r\n\r\n```\r\npost postponeComputation(1OOO, object : Runnable { \r\n    override fun run() {\r\n    println(42) \r\n    }\r\n)}\r\n```\r\n\r\n\r\n在 Kotlin 中，可以调用它并把一个 **lambda** 作为实参传给它。编译器会自动把它转换成一个 **Runnable** 的实例：\r\n\r\n```\r\npostponeComputation(lOOO) { println(42) }\r\n```\r\n完全等价的实现应该是下面这段代码中的显式**object**声明，它把**Runnable**实例存储在一个变量中，并且每次调用的时候都使用这个变量：\r\n\r\n```\r\nval runnable = Runnable { println(42) } \r\nfun handleComputation(){ postponeComputation(1OOO, runnable)} \r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},{"articleName":"Kotlin学习笔记（第四章）","createTime":"2018-10-02T21:49:47.000","lastModifiedTime":"2020-02-03T10:40:11.000","tag":"Kotlin","summary":" 1.接口的默认实现\n\n接口的方法可以有一个默认实现。与Java8不同的是，Java8中需要你","imageAddress":"/img/kotlin_3.png","articleAddress":"/config/study/Kotlin学习笔记（第四章）.md","articleContent":"---\ntitle: Kotlin笔记(三):基础篇more plus\ndate: 2018-10-02 21:49:47\nindex_img: /img/kotlin_3.png\ntags: Kotlin\n---\n\n### 1.接口的默认实现\n\n接口的方法可以有一个默认实现。与Java8不同的是，Java8中需要你在这样的实现上标注default关键字，对于这样的方法，Kotlin没有特殊的注解 ：只需要提供一个方法体\n\n```\ninterface Clickable{\n    fun click()\n    fun showOff = println(\"I'm clickable\")\n}\n```\n在实现接口的地方如果要显式地实现方法，在Kotlin中需要把 基类的名字放在尖括号中 ：\n```\nsuper<Clickable>.showOff() \n```\n<!--more--> \n### 2.定义类的继承结构\n\n    Java的类和方法默认是open的，而Kotlin中默认都是final的。 \n\n如果你想允许创建一个类的子类，需要使用 **open** 修饰符来标示这个类。此外，需要给每一个可以被重写的属性或方法添加open修饰符。\n\n> *注意，如果你重写了一个基类或者接口的成员，重写了的成员同样默认是 open的。如果你想改变这一行为，阻止你的类的子类重写你的实现，可以显式地将重写的成员标注为 **final** 。*\n\n\n\n### 3.嵌套类与内部类\n\nKotlin中没有显式修饰符的嵌套类与Java中的static嵌套类是一样的。要把它变成一个内部类来持有一个外部类的引用的话需要使用 **inner** 修饰符。\n\n在Kotlin中引用外部类实例的语法也与Java不同。需要使用 **this@Outer** 从 **Inner** 类去访问 **Outer** 类：\n\n\n```\nclass Outer{\n    inner class Inner{\n        fun getOuterReference() : Outer = this@Outer\n    }\n}\n```\n\n\n### 4.密封类：定义受限的类继承结构\n\n为父类添加一个 **sealed** 修饰符，对可能创建的子类做出严格的限制。\n\n如果你在 when 表达式中处理所有 **sealed** 类的子类，你就不再需要提供默认分支。注意， **sealed** 修饰符隐含的这个类是一个 **open** 类， 你不再需要显式地添加 **open** 修饰符。\n\n\n### 5.声明一个带非默认构造方法或属性的类\n\n举个栗子：\n\n```\nclass User constructor(_nickname: String) {\n    val nickname : String\n    \n    init{\n        nickname = _nickname\n    }\n}\n```\n在这个例子中，可以看到两个新的Kotlin关键宇：**constructor** 和 **init** 。 **constructor** 关键字用来开始一个主构造方法或从构造方法的声明。 **init** 关键字用来引入一个初始化语句块。这种语句块包含了在类被创建时执行的代码， 并会与主构造方法一起使用。\n\n> 如果你想要确保你的类不被其他代码实例化，必须把构造方法标记为 private：\n\n```\nclass Secretive private constructor() {}\n//一般这么做表示这个类是一个静态实用工具成员的容器或者是单例的\n```\n\n### 6.通过 getter 或 setter 访问支持字段\n\n假设你想在任何对存储在属性中的数据进行修改时输出日志，你声明了一个可变属性并且在每次 setter 访问时执行额外的代码。\n\n```\nclass ·user (val name: String) { \n    var address: String =\"unspecified\" \n        set(value: String) { \n            println (””“ A Address was changed for $name:\n            \"$field\" -> \"value\".\"\"\"\".trimIndent())\n            field = value\n        }\n    }\n```\n可以像平常一样通过使用 user.address ＝ \"new value\"， 来修改一个属性的值，这其实在底层调用了 setter。\n\n\n在 setter 的函数体中，使用了特殊的标识符 **field** 来访问支持字段的值。\n\n如果你想修改访问器的可见性，可以像下面这样：\n\n```\nclass LengthCounter {\n    var counter: Int = 0 \n    private set     //这下就不能在类外部修改这个属性了\n    \n    fun addWord(word: String){\n        counter += word.length\n    }\n}\n```\n\n### 7.数据类：自动生成通用方法的实现 \n\n如果想要你的类是一个方便的数据容器，你需要重写这些方法 ： **toString**、 **equals** 和 **hashCode** 。在Kotlin中你不必再去生成这些方法了 。如果为你的类添加 **data** 修饰符，必要的方法将会自动生成好。\n\n比如：\n```\ndata class Client(val name: String, val postalCode: Int)\n```\n\n### 8.数据类和不可变性： copy()方法\n\n为了让使用不可变对象的数据类变得更容易，Kotlin编译器为它们多生成了一个方法：一个允许 **copy** 类的实例的方法，并在 **copy** 的同时修改某些属性的值:\n\n\n```\nclass Client (val name: String, val postalCode: Int) {\n    fun copy(name: String = this.name, postalCode: Int = \n    this.postalCode) = Client(name, postalCode)\n}\n\n\n//使用\n>>> val bob = Client(\"Bob”, 973293) \n>>> println(bob.copy(postalCode = 382555)) \n```\n\n### 9.类委托：使用“by”关键字\n(装饰模式我还不是太了解，了解以后再记录)\n\n### 10.对象声明：创建单例易如反掌\n\n在面向对象系统设计中一个相当常见的情形就是只需要一个实例的类。在Java中，这通常通过单例模式来实现 \n\nKotlin 通过使用对象声明功能为这一切提供了最高级的语言支持。对象声明将类声明与该类的单一实例声明结合到了一起。 \n\n\n```\nobject Payroll { \n    val allErnployees = arrayListOf<Person>()\n\n    fun calculateSalary() { \n        for {person in allErnployees) { \n        ...\n        }\n    }\n}\n```\n> 对象声明通过object关键宇引入。一个对象声明可以非常高效地以一句话来定义一个类和一个该类的变量。 \n\n### 11.伴生对象：工厂方法和静态成员的地盘\n\n在类中定义的对象之一可以使用一个特殊的关键字来标记：**companion**。如果这样做，就获得了直接通过容器类名称来访问这个对象的方法和属性的能力，不再需要显式地指明对象的名称。最终的语法看起来非常像 Java 中的静态方法调用。\n\n```\nclass A { \n    companion object { \n        fun bar() { \n        println (\"Companion object called\") \n        }\n    }\n}\n\n\n\n>> A.bar() \nCompanion object called\n```\n\n\n伴生对象可以访问类中的所有private成员，包括private构造方法，它是实现工厂模式的理想选择。 \n\n```\nclass User private constructor(val nickname: String) {\n    companion object {\n        fun newSubscribingUser(email: String) =\n        User(email.substringBefore ('@')) \n        \n        fun newFacebookUser(accountld: Int) = \n        User(getFacebookName(accountld)) \n    }\n}\n\n\n>> val subscribingUser = User.newSubscribingUser (\"bob@gmail.com\") \n>> val facebookUser = User.newFacebookUser(4) \n>> println(subscribingUser.nickname)\nbob\n```\n\n### 小结：\n\n\n- Kotlin 的接口与 Java 的相似，但是可以包含默认实现 (Java 从第8版才开始支持)和属性。\n- 所有的声明默认都是 final 和 public 的。\n- 要想使声明不是 final 的，将其标记为 open。\n- internal 声明在同一模块中可见。\n- 嵌套类默认不是内部类。使用inner关键字来存储外部类的引用。\n- sealed 类的子类只能嵌套在自身的声明中（Kotlin 1.1 允许将子类放置在同一文件的任意地方）。\n- 初始化语句块和从构造方法为初始化类实例提供了灵活性。 \n- 使用 field 标识符在访问器方法体中引用属性的支持字段。\n- 数据类提供了编译器生成的 equals、 hashCode、 toString、 copy 和其他方法。 \n- 类委托帮助避免在代码中出现许多相似的委托方法。 \n- 对象声明是 Kotlin 中定义单例类的方法。\n- 伴生对象（与包级别函数和属性一起）替代了Java静态方法和字段定义。 \n- 伴生对象与其他对象一样，可以实现接口，也可以拥有有扩展函数和属性。\n- 对象表达式是 Kotlin中针对Java匿名内部类的替代品，并增加了诸如实现多个接口的能力和修改在创建对象的作用域中定义的变量的能力等功能。"},{"articleName":"Kotlin学习笔记（第三章）","createTime":"2018-10-01T21:49:47.000","lastModifiedTime":"2020-02-03T10:39:49.000","tag":"Kotlin","summary":" 1.顶层函数和属性\n\n在Kotlin中，可以把那些工具类里的函数直接放到代码文件的顶层，不用","imageAddress":"/img/kotlin_2.png","articleAddress":"/config/study/Kotlin学习笔记（第三章）.md","articleContent":"---\ntitle: Kotlin笔记(二):基础篇plus\ndate: 2018-10-01 21:49:47\nindex_img: /img/kotlin_2.png\ntags: Kotlin\n---\n\n### 1.顶层函数和属性\n\n在Kotlin中，可以把那些工具类里的函数直接放到代码文件的顶层，不用从属于任何的类。这些放在文件顶层的函数依然是包内的成员，如果你需要从包外访问它，则需要import，但不再需要额外包一层\n\n\n### 2.给别人的类添加方法：扩展函数和属性\n\n扩展函数非常简单，它就是一个类的成员函数，不过定义在类的外面。举个例子：\n\n```\npackage strings \nfun String.lastChar(): Char = this.get(this.length - 1) //this可以省略\n```\n从某种意义上说，你已经为String类添加了自己的方法。即使字符串不是代码的一部分，也没有类的源代码，你仍然可以在自己的项目中根据需要去扩展方法。\n\n> 注意，扩展函数并不允许你打破它的封装性。和在类内部定义的方法不同的是，扩展函数不能访私有的或者是受保护的成员。 \n>    \n> 对于你定义的一个扩展函数，它不会自动地在整个目范围内生效。相反，如果你要使用它，需要进行导入\n>      \n> 扩展函数并不存在重写，因为Kotiin会把它们当作静态函数对待\n\n\n下面是声明一个扩展属性：\n\n```\nval String.lastChar: Char get() = get(length - 1) \n```\n\n可以看到，和扩展函数一样，扩展属性也像接收者的一个普通的成员属性一样。这里，必须定义getter函数，因为没有支持字段，因此没有默认getter的实现。同理，初始化也不可以：因为没有地方存储初始值。\n\n    注意，当你需要从Java中访问扩展属性的时候，应该显式地调用它的getter函数\n    \n    \n### 3.可变参数：让函数支持任意数量的参数\n\n当你在调用一个函数来创建列表的时候，可以传递任意个数的参数给它：\n\n```\nval list= list0f(2, 3, 5, 7, 11) \n```\nKotlin的可变参数与Java类似，但语法略有不同：Kotlin在该类型之后不会再使用三个点，而是在参数上使用vararg修饰符。\n\nKotlin和Java 之间的另一个区别是，当需要传递的参数己经包装在数组中时，调用该函数的语法。在Java中，可以按原样传递数组，而Kotlin 则要求你显式地解包数组，以便每个数组元素在函数中能作为单独的参数来调用。从技术的角度来讲，这个功能被称为展开运算符，而使用的时候，不过是在对应的参数前面放一个*：\n\n```\nfun main(args: Array<String>）{\nval list = listOf(\"args:”,*args) \nprintln(list) \n}\n\n```\n\n\n### 4.键值对的处理：中缀调用和解构声明\n\n可以使用 mapOf 函数来创建 map:\n\n```\nval map= mapOf(l to \"one\"， 7 to \"seven\"， 53 to \"fifty-three\")\n```\n这行代码中的单词to不是内置的结构，而是一种特殊的函数调用，被称为中缀调用。 \n\n在中缀调用中，没有添加额外的分隔符，函数名称是直接放在目标对象名称和 参数之间的。以下两种调用方式是等价的：\n\n\n```\n1.to(\"one\")\n1 to \"one\"\n```\n\n中缀调用可以与只有一个参数的函数一起使用，无论是普通的函数还是扩展函 数。要允许使用中缀符号调用函数，需要使用 infix 修饰符来标记它。下面是一个 简单的 to 函数的声明：\n\n\n```\ninfix fun Any.to(other: Any) = Pair(this, other)\n```\n\nto 函数是一个扩展函数，可以创建一对任何元素，这意味着它是泛型接收者的 扩展：可以使用 1 to \"one\" 、\"one\" to 1、list to list.size()等写法。 \n\n\n\n### 5.让你的代码更整洁：局部函数和扩展\n\nKotlin可以在函数中嵌套类中提取的函数。这样，既可以获得所需的结构，也无须额外的语法开销。\n\n举个栗子：\n\n```\nclass User(val id: Int, val name: String, val address: String) \n\nfun saveUser(user : User){\n    if(user.name.isEmpty()){\n        ...\n    }\n    if(user.address.isEmpty()){\n        ...\n    }\n    //保存...\n}\n```\n如果将验证代码放到局部函数中，可以摆脱重复，并保持清晰的代码结构，可以这样做 ：\n\n\n```\nclass User(val id: Int, val name: String, val address: String) \n\nfun saveUser(user : User){\n    fun validate(user: User, value: String, fieldName: String){\n        if(value.isEmpty()){\n            ...\n        }\n    }\n    \n    validate (user, user.name, \"Name\")\n    validate (user, user.address, \"Address\")\n    //保存...\n    \n}\n```\n\n上面的代码看起来好多了，而且局部函数可以访问所在函数中的所有参数和变量。 我们可以利用这一点，去掉冗余的User参数，这里就不再演示了\n\n我们可以继续改进，把验证逻辑放到 User 类的扩展函数中。\n\n```\nclass User(val id: Int, val name: String, val address: String) \n\nfun User.validateBeforeSave(){\n    fun validate(value: String, fieldName: String){\n        if(value.isEmpty()){\n            ...\n        }\n    }\n    \n    validate (user.name, \"Name\")\n    validate (user.address, \"Address\")\n}\n\n\nfun saveUser(user : User){\n    user.validateBeforeSave()\n    //保存...\n}\n```\n\n**小结：**\n\n- Kotlin没有定义自己的集合类，而是在Java集合类的基础上提供了更丰富的API。\n\n- Kotlin可以给函数参数定义默认值，这样大大降低了重载函数的必要性，而且命名参数让多参数函数的调用更加易读。\n\n- Kotlin允许更灵活的代码结构：函数和属性都可以直接在文件中声明，而不仅仅是在类中作为成员。\n\n- Kotlin可以用扩展函数和属性来扩展任何类的API，包括在外部库中定义的类，而不需要修改其源代码，也没有运行时开销。 \n\n- 中缀调用提供了处理单个参数的，类似调用运算符方法的简明语法。\n\n- Kotlin为普通字符串和正则表达式都提供了大量的方便字符串处理的函数。 \n\n- 三重引号的字符串提供了一种简洁的方式，解决了原本在Java中需要进行大量啰嗦的转义和宇符串连接的问题。\n\n- 局部函数帮助你保持代码整洁的同时，避免重复。\n\n\n\n"},{"articleName":"Kotlin学习笔记（第二章）","createTime":"2018-09-30T21:49:47.000","lastModifiedTime":"2020-02-03T10:41:24.000","tag":"Kotlin","summary":">  在2017年的Google开发者大会上，Kotlin正式作为Android的官方开发语言闪亮登","imageAddress":"/img/kotlin_1.png","articleAddress":"/config/study/Kotlin学习笔记（第二章）.md","articleContent":"---\ntitle: Kotlin笔记(一):基础篇\ndate: 2018-09-30 21:49:47\nindex_img: /img/kotlin_1.png\ntags: Kotlin\n---\n\n>  在2017年的Google开发者大会上，Kotlin正式作为Android的官方开发语言闪亮登场。而现在已经到了2018年的下半年末，身为一名Android开发者，如果不会一点Kotlin，总感觉少了什么。  \r\n>   \r\n> 于是乎，我准备动手学一学这门“年轻”的新语言了。不过新学一些东西往往会因为知识的消化需要时间而导致知识接收的效率不高，所以这时候好记性不如烂笔头的优势才得以体现嘛！  \r\n> \r\n> 所以，初学阶段，我还是准备记一记笔记，这样也许会对我学这门语言有所帮助吧？!\r\n\r\n\r\n关于Kotlin的官方文档，地址如下：\r\n\r\n[Kotlin学习](https://www.kotlincn.net/docs/reference/)\r\n<!--more--> \r\n\r\n### 1.在 Kotlin 中，if是表达式，而不是语句。\r\n\r\n 语句和表达式的区别在于，表达式有值，并且能作为另一个表达式的一部分使用；而语句总是包围着它的代码块中的顶层元素，并且没有自己的值。\r\n- 在Java中，所有的控制结构都是语句。而在Kotlin中，除了循环（ for, do 和 do/while ）以外大多数控制结构都是 表达式。\r\n这种结合控制结构和其他表达式的能力让你可以简明扼要地表示许多 常见的模式，稍后你会在本书中看到这些内容。\r\n- 另一方面，Java中的赋值操作是表达式，在Kotlin中反而变成了语句。这有助于避免比较和赋值之间的混淆，而这种混淆是常见的错误来源。\r\n\r\n\r\n### 2.声明变量的关键字有两个 ：\r\n\r\n- val （来自 value） 一一不可变引用。使用 val 声明的变量不能在初始化之 后再次赋值。它对应的是 Java 的 final 变量。  \r\n- var （来自 variable） 一一可变引用。这种变量的值可以被改变。这种声明对 应的是普通（非 final）的 Java 变量。\r\n\r\n\r\n### 3.局部变量的引用\r\n\r\n和许多脚本语言一样， Kotlin 让你可 以在字符串字面值中引用局部变量，只需要在变量名称前面加上字符$。\r\n\r\n这等价于 Java 中的字符串连接（ \"Hello,\"+ name ＋\"！\"），效率一样但是更紧凑。\r\n\r\n```\r\nfun main(args: Array<String>) {\r\n    val name = if(args.size > 0) args[0] else \"Kotlin\"\r\n    println(\"Hello, $name !\")\r\n}\r\n```\r\n\r\n\r\n还可以引用更复杂的表达式，而不是仅限于简单的变量名称，只需要把表达式 用花括号括起来.\r\n\r\n### 4.在Java中可以用switch语句完成的，而Kotlin 对应的结构是when\r\n\r\n```\r\nfun getMnemonic(color: Color) = \r\nwhen (color) { \r\nColor . RED ->”Richard\" \r\nColor.ORANGE ->”Of” \r\nColor.YELLOW ->”York\" \r\nColor .GREEN ->”Gave” \r\nColor.BLUE ->”Battle\" \r\nColor ．工NDIGO ->”In” \r\nColor.VIOLET ->”Vain \r\n}\r\n```\r\n\r\n  在一个 when 分支上合并多个选项：\r\n  \r\n```\r\nfun getWarmth(color: Color) = when(color) {\r\nColor.RED, Color.ORANGE, Color.YELLOW - > ”warm”\r\nColor.GREEN -> ”neutral”\r\nColor.BLUE, Color.INDIGO, Color.VIOLET ->”cold”\r\n}\r\n```\r\n上面的代码中，也可以导入枚举常量后不用限定词就可以访问。比如去掉花括号里的Color也是可以的。\r\n\r\n> Kotlin中的when结构比Java中的switch强大得多。switch要求必须使用常量（枚举常量、字符串或者数字字面值）作为分支条件，和它不一样， when允许使用任何对象。\r\n\r\n\r\n\r\n### 5.类型判断\r\n\r\n在Kotlin中，你要使用is检查来判断一个变量是否是某种类型。is检查和Java中的instanceOf相似，不过在instanceOf检查之后还需要显式地加上类型转换。\r\n\r\n在Kotlin中，编译器帮你完成了这些工作。如果你检查过一个变量是某种类型，后面就不再需要转换它，可以就把它当作你检查过的类型使用。\r\n\r\n使用as关键字来表示到特定类型的显式转换；\r\n\r\n\r\n### 6.循环中的\"in\"关键字\r\n\r\nKotlin里面关键字“in”有许多作用，比如检查区间的成员；作为when的分支；在for循环中使用等。关于in如何在list中使用，下章再介绍\r\n\r\n\r\n### 7.关于\"try\"\r\n\r\nKotlin中的try关键字就像if和when一样,引入了一个表达式，可以把它的值赋给一个变量。不同于if，你总是需要用花括号把语句主体括起来。和其他语句一样，如果其主体包含多个表达式，那么整个 try 表达式的值就是最后一个表达式的值。"},{"articleName":"Bugly热修复使用及多渠道打包","createTime":"2018-09-26T21:49:47.000","lastModifiedTime":"2020-02-03T10:06:52.000","tag":"Android","summary":" <font color=\"7FFF00\">头\n\n不知道你是否遇到过这个情况，项目上线后或者开","imageAddress":"/img/bugly.png","articleAddress":"/config/study/Bugly热修复使用及多渠道打包.md","articleContent":"---\ntitle: Bugly热修复使用及多渠道打包\ndate: 2018-09-26 21:49:47\nindex_img: /img/bugly.png\ntags: Android\n---\n\n## <font color=\"#7FFF00\">头\n\n不知道你是否遇到过这个情况，项目上线后或者开始给别人使用的时候，冷不丁的冒出个Bug，这时候首先要干嘛？\n\n**先看崩溃日志啊**\n\n看完崩溃日志你知道了造成崩溃的原因，然后干嘛？\n\n**开始甩锅啊**\n\n当查明了是谁造成的这个崩溃后，你发现不是你的问题，于是你心中一乐，长舒一口气，仰天大笑：码海沉浮又几载，我辈岂是蓬蒿人；笑完便准备躺床上睡觉去——秋豆麻袋，是不是忘了什么东西？\n\n是的，即使你发现了问题，并且找到了问题的来源，这时候还差一步：解决问题的办法！如何解决？\n\n**发布新版本？**\n\n这样不觉得很麻烦吗？特别是如果一个项目处于初期阶段，Bug是想甩都甩不掉的，如果每发现一次崩溃，都需要靠发布一个新版本去解决的话，那未免就太麻烦了。不光是开发者麻烦，使用者也会因为频繁的升级而不耐烦（just like me），那问题又回来了，如何解决？\n\n**热修复啊**\n\n通过线上修复Bug，让用户在神不知鬼不觉的情况下就进行了一次应用更新，麻麻再也不用担心App崩溃啦！（不存在的）\n\n热修复还有个隐藏的好处，那就是在测试人员不够（开发兼测试），测试机型不够的情况下可以显著改善App的崩溃率。好吧，准备开始使用吧。\n\n## <font color=\"#000066\">身\n\n### 一、为什么要用Bugly\n\n市面上关于热修复和崩溃日志监测的相关技术和SDK种类各不相同，为什么偏偏要用Bugly呢？\n\n- 可以获取到App崩溃日志\n- 可以集成Think热修复\n- 界面好看，方便管理版本\n- 免费\n- （凑巧就用了这一款，其他的都没有用过）\n\n基于以上原因，最后就使用了Bugly去解决上面提到过的问题；\n\n### 二、Bugly热更新接入流程\n\n其实关于Bugly热更新的详细接入流程，官方的文档介绍的非常详细，对新手比较友好，我第一次使用也是直接参照的文档，下面是官方文档的地址：\n\n[【Bugly Android热更新使用指南】](https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix/?v=20180709165613)\n\n虽然官方有例子，这里还是写了一个简化版，也方便以后哪天自己忘记了依旧能快速使用：\n\n#### 第一步：添加依赖插件\n\n在你的项目更目录下的“build.gradle”中添加：\n\n```\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        // tinkersupport插件, 其中lastest.release指拉取最新版本，也可以指定明确版本号，例如1.0.4\n        classpath \"com.tencent.bugly:tinker-support:1.1.2\"\n    }\n}\n```\n在写这篇文章的时候，最新的版本就是1.1.2\n\n#### 第二步：配置依赖插件\n\n##### gradle配置\n\n在app module的“build.gradle”文件中添加（示例配置）：\n\n\n```\n...\n// 依赖插件脚本\napply from: 'tinker-support.gradle'\n\nandroid {\n        defaultConfig {\n          ndk {\n            //设置支持的SO库架构\n            abiFilters 'armeabi' //, 'x86', 'armeabi-v7a', 'x86_64', 'arm64-v8a'\n          }\n        }\n      }\n      dependencies {\n         implementation 'com.android.support:multidex:1.0.1'\n        // 多dex配置\n        //注释掉原有bugly的仓库\n        //compile 'com.tencent.bugly:crashreport:latest.release'//其中latest.release指代最新版本号，也可以指定明确的版本号，例如1.3.4\n        implementation 'com.tencent.bugly:crashreport_upgrade:1.3.5'\n        // 指定tinker依赖版本（注：应用升级1.3.5版本起，不再内置tinker）\n        implementation 'com.tencent.tinker:tinker-android-lib:1.9.6'\n        implementation 'com.tencent.bugly:nativecrashreport:latest.release'\n        //其中latest.release指代最新版本号，也可以指定明确的版本号，例如2.2.0\n      }\n```\n在这个版本的SDK里面，已经集成了崩溃日志上传的功能哦！\n\n##### tinker-support.gradle的配置\n\n接下来，你要在app module目录下创建另外一个gradle文件，命名为“tinker-support.gradle”，然后对它进行配置：\n\n```\napply plugin: 'com.tencent.bugly.tinker-support'\n\ndef bakPath = file(\"${buildDir}/bakApk/\")\n\n/**\n * 此处填写每次构建生成的基准包目录\n */\ndef baseApkDir = \"app-0921-14-52-06\"\n\n/**\n * 对于插件各参数的详细解析请参考\n */\ntinkerSupport {\n\n    // 开启tinker-support插件，默认值true\n    enable = true\n\n    // 指定归档目录，默认值当前module的子目录tinker\n    autoBackupApkDir = \"${bakPath}\"\n\n    // 是否启用覆盖tinkerPatch配置功能，默认值false\n    // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch\n    overrideTinkerPatchConfiguration = true\n\n    // 编译补丁包时，必需指定基线版本的apk，默认值为空\n    // 如果为空，则表示不是进行补丁包的编译\n    // @{link tinkerPatch.oldApk }\n    baseApk = \"${bakPath}/${baseApkDir}/app-release.apk\"\n\n    // 对应tinker插件applyMapping\n    baseApkProguardMapping = \"${bakPath}/${baseApkDir}/app-release-mapping.txt\"\n\n    // 对应tinker插件applyResourceMapping\n    baseApkResourceMapping = \"${bakPath}/${baseApkDir}/app-release-R.txt\"\n\n    // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性\n    tinkerId = \"1.0.1-patch\"                //tinkerId = \"1.0.1-patch\"            tinkerId = \"1.0.1-base\"\n\n    // 构建多渠道补丁时使用\n    // buildAllFlavorsDir = \"${bakPath}/${baseApkDir}\"\n\n    // 是否启用加固模式，默认为false.(tinker-spport 1.0.7起支持）\n    // isProtectedApp = true\n\n    // 是否开启反射Application模式\n    enableProxyApplication = false\n\n    // 是否支持新增非export的Activity（注意：设置为true才能修改AndroidManifest文件）\n    supportHotplugComponent = true\n\n}\n\n/**\n * 一般来说,我们无需对下面的参数做任何的修改\n * 对于各参数的详细介绍请参考:\n * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97\n */\ntinkerPatch {\n    //oldApk =\"${bakPath}/${appName}/app-release.apk\"\n    ignoreWarning = false\n    useSign = true\n    dex {\n        dexMode = \"jar\"\n        pattern = [\"classes*.dex\"]\n        loader = []\n    }\n    lib {\n        pattern = [\"lib/*/*.so\"]\n    }\n\n    res {\n        pattern = [\"res/*\", \"r/*\", \"assets/*\", \"resources.arsc\", \"AndroidManifest.xml\"]\n        ignoreChange = []\n        largeModSize = 100\n    }\n\n    packageConfig {\n    }\n    sevenZip {\n        zipArtifact = \"com.tencent.mm:SevenZip:1.1.10\"\n//        path = \"/usr/local/bin/7za\"\n    }\n    buildConfig {\n        keepDexApply = false\n        //tinkerId = \"1.0.1-base\"\n        //applyMapping = \"${bakPath}/${appName}/app-release-mapping.txt\" //  可选，设置mapping文件，建议保持旧apk的proguard混淆方式\n        //applyResourceMapping = \"${bakPath}/${appName}/app-release-R.txt\" // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配\n    }\n}\n\n```\n这里面的配置比较多，一开始看还是有点儿眼花缭乱的，所以得慢慢来；\n\n这里对其中的几点进行说明：\n\n - *baseApkDir* ： 这里填写每次构建生成的基准包目录，每次打包的时候，都会有新的目录和新的基准包生成，但是只有你打算发布的那一个的目录才是有效的。\n - *tinkerId* ： 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性。比如你的第一个基准包打包的时候可以把这个id设置为“1.0.0-base”，当你想打包热修复补丁包的时候，需要把这个id换成1.0.0-patch。\n\n\n更详细的配置项参考：[tinker-support配置说明](https://bugly.qq.com/docs/utility-tools/plugin-gradle-hotfix/)\n\n#### 第三步：初始化SDK\n\n\n上面的“tinker-support.gradle”中的enableProxyApplication属性设置的是false，是Tinker推荐的接入方式。\n\n##### 自定义Application，当enableProxyApplication为false的情况\n\n```\npublic class SampleApplication extends TinkerApplication {\n    public SampleApplication() {\n        super(ShareConstants.TINKER_ENABLE_ALL, \"xxx.xxx.SampleApplicationLike\",\n                \"com.tencent.tinker.loader.TinkerLoader\", false);\n    }\n}\n```\n**SampleApplicationLike**需要是自定义的继承**DefaultApplicationLike**的类，不要忘了在**AndroidManifest.xml**中声名上面的这个Application哦。\n\n\n```\npublic class SampleApplicationLike extends DefaultApplicationLike {\n\n\n    public static final String TAG = \"Tinker.SampleApplicationLike\";\n\n    public SampleApplicationLike(Application application, int tinkerFlags,\n                                 boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime,\n                                 long applicationStartMillisTime, Intent tinkerResultIntent) {\n        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);\n    }\n\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        // 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId\n        // 调试时，将第三个参数改为true\n        Bugly.init(getApplication(), \"900029763\", false);\n    }\n\n\n    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)\n    @Override\n    public void onBaseContextAttached(Context base) {\n        super.onBaseContextAttached(base);\n        // you must install multiDex whatever tinker is installed!\n        MultiDex.install(base);\n\n        // 安装tinker\n        // TinkerManager.installTinker(this); 替换成下面Bugly提供的方法\n        Beta.installTinker(this);\n    }\n\n    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)\n    public void registerActivityLifecycleCallback(Application.ActivityLifecycleCallbacks callbacks) {\n        getApplication().registerActivityLifecycleCallbacks(callbacks);\n    }\n}\n```\n\n上面需要注意的是在“onCreate()”方法中进行初始化的时候，填入的appId是你在Bugly创建的项目的Appid，其他地方基本上不用改了\n\n\n##### 自定义Application，当enableProxyApplication为true的情况\n\n这种的接入方式要简单许多，无须你改造Application\n\n```\npublic class MyApplication extends Application {\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        // 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId\n        // 调试时，将第三个参数改为true\n        Bugly.init(this, \"900029763\", false);\n    }\n\n    @Override\n    protected void attachBaseContext(Context base) {\n        super.attachBaseContext(base);\n        // you must install multiDex whatever tinker is installed!\n        MultiDex.install(base);\n\n\n        // 安装tinker\n        Beta.installTinker();\n    }\n\n}\n```\n\n#### 第四步：AndroidManifest.xml配置\n\n##### 1.权限配置：\n\n```\n<uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\n<uses-permission android:name=\"android.permission.INTERNET\" />\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n<uses-permission android:name=\"android.permission.READ_LOGS\" />\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n```\n##### 2.Activity配置：\n\n```\n<activity\n    android:name=\"com.tencent.bugly.beta.ui.BetaActivity\"\n    android:configChanges=\"keyboardHidden|orientation|screenSize|locale\"\n    android:theme=\"@android:style/Theme.Translucent\" />\n```\n##### 3.配置FileProvider\n\n    注意：如果您想兼容Android N或者以上的设备，必须要在AndroidManifest.xml文件中配置FileProvider来访问共享路径的文件。\n\n\n```\n        <!--热更新需要的Provider-->\n        <provider\n            android:name=\"android.support.v4.content.FileProvider\"\n            android:authorities=\"${applicationId}.fileProvider\"\n            android:exported=\"false\"\n            android:grantUriPermissions=\"true\">\n            <meta-data\n                android:name=\"android.support.FILE_PROVIDER_PATHS\"\n                android:resource=\"@xml/provider_paths\"/>\n        </provider>\n```\n在res目录新建xml文件夹，创建provider_paths.xml文件如下：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<paths xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <!-- /storage/emulated/0/Download/${applicationId}/.beta/apk-->\n    <external-path name=\"beta_external_path\" path=\"Download/\"/>\n    <!--/storage/emulated/0/Android/data/${applicationId}/files/apk/-->\n    <external-path name=\"beta_external_files_path\" path=\"Android/data/\"/>\n</paths>\n```\n#### 第五步：混淆配置\n\n为了避免混淆SDK，在Proguard混淆文件中增加以下配置：\n```\n-dontwarn com.tencent.bugly.**\n-keep public class com.tencent.bugly.**{*;}\n# tinker混淆规则\n-dontwarn com.tencent.tinker.**\n-keep class com.tencent.tinker.** { *; }\n```\n\n### 三、打包\n\n当上面的环境配置都没有问题之后，就可以进行打包了。\n\n打包之前，你还得配置一下编译正式版apk所需要的**keystore.jks**文件，这个文件怎么创建的就不介绍了，这里主要介绍一下如何配置：\n\n在app moudle目录下的“build.gradle”中配置：\n\n```\nandroid {\n    signingConfigs {\n        release {\n            keyAlias 'xxxxxxxx'\n            keyPassword 'xxxxxxxx'\n            storeFile file('../keystore.jks')\n            storePassword 'xxxxxxxx'\n        }\n    }\n    ...\n    buildTypes {\n        release {\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n            signingConfig signingConfigs.release\n        }\n    }\n}\n```\n其中的各项参数就不必做说明了\n\n\n\n然后就是打包过程![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-001.png)\n\n**打包过程中需要注意之前提到过的tinkerId的配置，以及目录的配置，很重要哦！**\n\n生成的基准包会在这个目录\n\n![image](https://bugly.qq.com/docs/img/hotfix/android/Snip20170209_2.png?v=20180709165613)\n\n生成的补丁包会在这个目录\n\n![image](https://bugly.qq.com/docs/img/hotfix/android/1479216059696.png?v=20180709165613)\n\n然后就准备开始使用吧\n\n### 四、使用\n\n找到你创建的产品，然后进入到下面的界面\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-002.png)\n\n接着，发布新补丁吧，看一看效果\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-003.png)\n\n具体的效果可以自行尝试一下，不过有时候你会遇到上传不成功的情况，一般下发后要过5到10分钟才会生效（可能是我的网络问题），如果太久没效果，应该是哪里出问题了\n\n## <font color=\"#660066\">尾\n\n前面的所有操作都尝试过后，接下来你可能就会面临新的需求了。比如说，多渠道打包的实现，比较旧的办法是通过productFlavors去实现分别打包，不过这样会有一个弊端，即有多少渠道打包流程就执行多少次，这样效率显然是不够的；\n\n于是乎，新的打包方案出来了：\n\n### 使用Walle进行多渠道打包\n\n下面是Walle的github地址：\n\n[Walle（瓦力）：Android Signature V2 Scheme签名下的新一代渠道包打包神器](https://github.com/Meituan-Dianping/walle)\n\n它的接入文档写的也十分友好，接下来实际操作一遍：\n\n\n#### Walle的Gradle接入\n\n在项目根目录的 **build.gradle** 中添加依赖：\n\n```\nbuildscript {\n    dependencies {\n        classpath 'com.meituan.android.walle:plugin:1.1.6'\n    }\n}\n```\n然后在app module中的 **build.gradle** 添加：\n\n```\napply plugin: 'walle'\n\ndependencies {\n    compile 'com.meituan.android.walle:library:1.1.6'\n}\n```\n并进行插件配置\n\n```\nwalle {\n    // 指定渠道包的输出路径\n    apkOutputFolder = new File(\"${project.buildDir}/outputs/channels\");\n    // 定制渠道包的APK的文件名称\n    apkFileNameFormat = '${appName}-${packageName}-${channel}-${buildType}-v${versionName}-${versionCode}-${buildTime}.apk';\n    // 渠道配置文件\n    channelFile = new File(\"${project.getProjectDir()}/channel\")\n}\n```\n接着在app module目录下创建一个文件，和上面配置中要保持一致，就叫 **channel**\n```\n360\nyingyongbao\nbaidu\nwandoujia\nxiaomi\noppo\nlenovo\nhuawei\ndefault_channel\n# 打包命令 gradlew clean assembleReleaseChannels  或者 gradlew assembleReleaseChannels\n```\n最后，在你的Application中的**onCreate**方法里添加：\n\n```\n        String channel = WalleChannelReader.getChannel(getApplication());\n        Bugly.setAppChannel(getApplication(), channel);\n```\n如果你实现的是**SampleApplicationLike**，也是在它的**onCreate**方法里添加即可。\n\n接下来通过运行上面的打包命令或者通过图中的手动操作，都是可以打包的\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/bugly-004.png)\n\n\n## <font color=\"#dddd00\">末\n\n至此，基本上整个配置流程就到此结束!!!\n\n不过有一个问题我一直不知道如何解决，就是打包基准包的命名，在 **tinker-support.gradle** 进行配置是不起效果的，试了好久都没效果，看来还得交给其他小伙伴们解决了\n\n\n\n*那么*\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Bugly%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/zaihui.png)\n"},{"articleName":"Android开发者编写自己的API接口：从零开始（二）","createTime":"2018-08-14T21:49:47.000","lastModifiedTime":"2020-02-03T10:18:51.000","tag":"Android","summary":" 前言\n\n\n\n在上一篇[Android开发者编写自己的API接口（上）](https://old","imageAddress":"/img/api_2.png","articleAddress":"/config/study/Android开发者编写自己的API接口：从零开始（二）.md","articleContent":"---\ntitle: Android开发者编写自己的API接口：从零开始（二）\ndate: 2018-08-14 21:49:47\nindex_img: /img/api_2.png\ntags: Android\n---\n\n## 前言\n\n\n\n在上一篇[Android开发者编写自己的API接口（上）](https://oldchen.top/2018/08/05/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/)中，已经介绍了如何搭建一个基本的开发环境，以及接口的编写，最后是能够成功运行的。\n\n这一篇将更进一步，主要解决下面两个问题：\n\n- ①：如何让后台项目运行在TomCat上\n- ②：如何在云服务器上部署自己的项目\n    \n## Start\n\n#### 一、本地Tomcat的使用\n\n##### 1.1、安装Tomcat\n使用TomCat，自然是要TomCat的安装包咯\n\n[安装包下载地址](https://tomcat.apache.org/download-90.cgi)\n\n![image](\nhttps://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/001.png)\n\n由于我们本地应该都是已经安装配置过JDK了的，所以安装Tomcat的时候一路Next就行了\n\n\n##### 1.2、配置Gradle\n首先，在项目的gradle所在的目录下创建gradle.properties，然后在里面添加：\n```\n# true就去打包War，否则不打包\nBUILD_WAR=true\n```\n![image](\nhttps://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/002.png)\n\n接着在build.gradle中添加：\n\n\n```\nif (BUILD_WAR.toBoolean()) {\n    apply plugin: 'war'\n}\n\ndependencies {\n    ...\n    if (BUILD_WAR.toBoolean()) {\n        providedRuntime('org.springframework.boot:spring-boot-starter-tomcat')\n    }\n}\n```\n![image](\nhttps://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/003.png)\n\n同时，不要忘了创建一个ServletInitializer类，用于SpringBoot的初始化\n\n```\npublic class ServletInitializer extends SpringBootServletInitializer {\n\n\t@Override\n\tprotected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n\t\treturn application.sources(TestForDemoApplication.class);\n\t}\n\n}\n```\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/008.png)\n\n\n这些都完成后，在Terminal控制台输入：\n\n```\ngradlew assemble\n```\n\n等待结果，然后就可以看到一个war包了\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/004.png)\n\n##### 1.3、配置Tomcat\n\n找到demo-0.0.1-SNAPSHOT.war所在目录，然后将其更名为oldchen.war\n\n    注意，这里修改后的名字将会与部署到Tomcat上的网络请求地址有关哦\n\n![image](\nhttps://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/005.png)\n\n然后找到Tomcat的安装目录下的webapps目录，将里面的其他文件和文件夹删除，把oldchen.war复制到该目录\n\n接下来，在Tomcat目录下的bin目录中运行Tomcat9w.exe\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/006.png)\n\n然后你会发现，webapps目录下多了一个文件\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/007.png)\n\n\n##### 1.4、测试本地Tomcat\n\n接下来，访问地址：\n\nhttp://localhost:8080/oldchen/user/user?account=oldchen\n\n结果：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/009.png)\n\n可以看到，本地的Tomcat已经部署成功，接下来就是云服务器上部署Tomcat了。\n\n\n#### 二、云服务器上Tomcat的部署\n\n##### 2.1、购买云服务器\n\n想在云服务器上部署Tomcat，首先需要购买一个服务器，我买的是腾讯云的服务器，初次接触的同学建议去使用试用的云服务器，等操作成功后再买也不迟\n\n\n出于对初学者的人文关怀（没错，Is me），这里我使用的是Windows版的服务器：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/010.png)\n\n\n为了能够正常访问服务器的地址，需要给服务器配置一下安全组，安全组中需要添加这样一项规则：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/011.png)\n\n然后，使用远程连接，连接到云服务器，具体操作是：\n    \n    一、win+R\n    二、输入mstsc\n    三、输入云服务器的Ip地址，用户名以及密码，连接\n\n如果你使用的是windows2016版的服务器，同时遇到了\"身份验证错误，要求的函数不支持\"，而且你恰好是win10家庭版，那么下面有解决办法：\n[windows10家庭版 远程桌面报错](https://jingyan.baidu.com/album/67508eb47ae5499ccb1ce410.html?picindex=3)\n\n\n成功登录后，整个界面只有一个孤伶伶的回收站，到了这步，就准备开始配置吧。\n\n\n##### 2.2、配置云服务器\n\n云服务器上面运行项目只需要Tomcat+Mysql+Navicat+JDK，配置方法和之前在本地配置是一样的，不过这里不建议使用上传的方法，因为上传实际上和下载是一样的，有时候还会受限于你自己宽带的上行速度。\n\n\n\n重新下载安装JDK是很头疼的，下面是详细教程：\n\n[非常详细图文JDK和Tomcat安装和配置的图文教程](https://blog.csdn.net/qq_32519693/article/details/71330930)\n\n\n全部需要准备的文件如下：\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/012.png)\n\n其中，**PatchNavicat** 用于Navicat的破解，在上一篇的链接中已经说明。\n\n而**oldchen.sql**则是通过本地Navicat生成Mysql文件，具体操作是：右键你选中的数据库，选择【转储SQL文件】→【结构和数据】，然后就可以生成了。使用方法就是在云服务器上创建一个数据库后选择【运行SQL文件】即可。\n\n这样，本地数据库的迁移就完成了。剩下的操作与之前介绍的基本一致，不过有一点需要注意，为了开启外网连接，需要在Tomcat安装目录下找到conf目录，修改其中的server.xml文件：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/013.png)\n\n将port由8080修改为80\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/014.png)\n\n\n当你完成全部的操作后，就可以测试接口了。\n\n##### 2.3、测试云服务器接口\n\n\n只要你的步骤是ok的，那么云服务器不会有什么问题。\n\n由于在写这篇文章期间，我又多写了个登录接口，所以这里的测试例子用的是新的接口，仅供参考：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89/015.png)\n\n\n请求地址是：http://111.230.251.115/oldchen/user/login\n\n\n\n## 后语\n\n那么，编写接口的学习就到此为止了。\n\n虽然有待完善的地方还不少，比如通过数据库指令对数据库进行增删改查、数据库之间相互关联等等，许多知识都需要慢慢学的。\n\n此文章权当入门之径，剩下的还得靠大家自己多多钻研啦，毕竟作者本人需要学的地方也太多了，如有错误之处，还望指出，互相学习，岂不乐哉。\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%A1%A8%E6%83%85%E5%8C%85/%E5%91%8A%E8%BE%9E2.jpg)\n\n\n\n\n\n"},{"articleName":"Android开发者编写自己的API接口：从零开始（一）","createTime":"2018-08-05T21:49:47.000","lastModifiedTime":"2020-02-03T10:13:57.000","tag":"Android","summary":" 序\n\n作为一名Android开发人员，想要实现对一些数据的操作和展示，可以通过一些提供Api接","imageAddress":"/img/api_1.png","articleAddress":"/config/study/Android开发者编写自己的API接口：从零开始（一）.md","articleContent":"---\ntitle: Android开发者编写自己的API接口：从零开始（一）\ndate: 2018-08-05 21:49:47\nindex_img: /img/api_1.png\ntags: Android\n---\n\n## 序\n\n作为一名Android开发人员，想要实现对一些数据的操作和展示，可以通过一些提供Api接口的网站去获取，虽然Api市场上种类繁多，不过别人提供的接口未必就是自己想要的，到最后，还是得自己去实现Api接口。\n\n毕竟，最了解自己需求的人，还得是自己。\n\n## 准备\n\n很多小伙伴应该都会有着类似的需求，不过想去做的时候，常常无从下手。\n\n所以这里做了一个整合，关于如何搭建开发环境，以及所需工具的下载等。\n\n\n参考文章：\n\n- [Android程序员搭建一个属于自己的服务器，不再求各种公共API](https://www.jianshu.com/p/4a0d40806ea2)\n- [JAVA后台搭建(springboot+mybatis+mysql)项目搭建](https://www.jianshu.com/p/f91ca5814bcf)\n\n## 步骤\n\n一套开发环境下来，需要下面这些步骤：\n\n- 1：搭建开发环境，IntelliJ + spring-boot + mybatis\n- 2：搭建数据库，mysql + navicat\n- 3：搭建运行环境，tomcat + 腾讯云（或者阿里云）\n\n\n## 开始\n\n### 一、搭建开发环境\n\n\n#### 1.1 IntelliJ IDEA的安装\n\nAndroid开发者所使用的Android studio是基于这个IDEA开发的，所以两者的界面非常非常相似。\n\n而且现在比较流行的Android开发语言Kotlin也是由IntelliJ IDEA的开发公司JetBrains所开发的。\n\n##### 下载 IntelliJ IDEA\n\n首先，下载安装包——[【IntelliJ下载地址】](https://www.jetbrains.com/idea/download/#section=windows)\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001.png)\n\n##### 安装 IntelliJ IDEA\n\n下载完成后，就开始安装了\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-001.png)\n\nNext到下面的界面，可以自行选择\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-002.png)\n\n\n然后一直下一步，到可以运行IDEA，然后你应该会遇到需要购买的提示，破解的教程请看：\n\n[Windows7下安装与破解IntelliJ IDEA2017](https://blog.csdn.net/yangying496875002/article/details/73603303)\n\nwin10也是适用的。\n\n\n#### 1.2 MySQL的安装\n\n##### 下载MySQL\n\n这里使用的是mysql-5.7.17.msi，下载地址是：\n\n[MYSQL下载地址](https://downloads.mysql.com/archives/installer/)\n\n\n##### 安装MySQL\n\n下载完成后进行安装：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-006.png)\n\n这里只选择了Server\n\n然后一直下一步\n\n到了设置密码这里，我设置的密码是【oldchen】,后面项目配置的密码也是这个，这里你可以随便设置自己的密码，不过后面配置的时候要保证密码输入一致就是：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-007.png)\n\n\n然后一直下一步，直到安装成功，接下来就是如何去操作数据库。\n\n\n#### 1.3 Navicat的安装\n\nNavicat用来对数据库进行操作，也是需要付费购买的，破解地址：\n[Navicat for MySQL 安装和破解（完美）](https://blog.csdn.net/wypersist/article/details/79834490)\n\n\n可以使用之后，来到如下界面：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-008.png)\n\n然后创建MYSQL连接：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-009.png)\n\n输入相关信息：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-010.png)\n\n然后就可以看到创建的连接了，右键→新建数据库：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-011.png)\n\n\n新建的数据库名字设置为oldchen,接下来双击这个数据库，新建一个user表,表中包含account,password,username以及自增主键id，具体操作如图所示：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/gif/001.gif)\n\n\n创建这个表后，我们可以添加一条数据：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-012.png)\n\n\n然后，开始配置IntelliJ IDEA\n\n#### 1.4 IntelliJ IDEA的配置\n\n\n##### 搭建SpringBoot项目\n\n打开IntelliJ，左上角 File → New → Project，创建新项目：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-013.png)\n\n\n然后\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-004.png)\n\n\n接下来是选择依赖的界面，选中图中的全部依赖\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-005.png)\n\n下一步\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-019.png)\n\n\n开始项目构建，需要等待一定的时间，构建完成后的项目结构是这样的：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-015.png)\n\n\n结合之前新建的数据库，在resources目录下的application.properties中进行配置：\n\n\n```\n#oldchen为创建的数据库名字\nspring.datasource.url =jdbc:mysql://localhost:3306/oldchen\nmybatis.type-aliases-package = com.example.demo\n# 数据库用户名\nspring.datasource.username = root\n# 数据库密码\nspring.datasource.password = oldchen\n\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\n\n#端口号\nspring.session.store-type=none\nspring.http.encoding.charset=UTF-8\n```\n\n接下来就开始写接口啦\n\n\n#### 1.5 接口的编写\n\n\n由于我们之前在操作名为【oldchen】的数据库时，还新建了一个【user】表，所以这里先创建一个User类：\n\n\n```\npublic class User {\n    private Integer id;\n    private String account;\n    private String password;\n    private String userName;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getAccount() {\n        return account;\n    }\n\n    public void setAccount(String account) {\n        this.account = account;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n}\n```\n\n\n然后创建UserMapper，用于查询（根据字段account查询）\n\n\n```\n@Mapper\npublic interface UserMapper {\n\n    @Select(\"select * from user where account = #{account}\")\n    User findByAccount(String account);\n\n}\n```\n\n\n接着创建UserController，用于对数据的处理：\n\n\n```\n@RestController\n@RequestMapping({\"/user\"})\npublic class UserController {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @RequestMapping(value=\"/user\")\n    @ResponseBody\n    public String getUserInfoByName(String account) {\n        User user = userMapper.findByAccount(account);\n        if (user == null){\n            return \"用户名保不存在\";\n        } else {\n            return \"用户名存在——\" + user.getUserName();\n        }\n    }\n}\n```\n\n\n最后项目结构如下：\n\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-016.png)\n\n\n### 二、测试接口\n\n首先，运行项目\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-017.png)\n\n\n当项目正常运行后，测试下面的地址：\n\nhttp://localhost:8080/user/user?account=oldchen\n\n结果：\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/Android%E5%BC%80%E5%8F%91%E8%80%85%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84API%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%B8%80%EF%BC%89/001-018.png)\n\n测试成功啦！\n\n\n## 后续\n\n\n关于Api接口的学习，先到这里。\n\n后面还会写关于如何将项目放在TomCat上，最后放在云服务器上，通过外网地址访问接口\n\n那么，未完待续...\n\n\n\n![image](https://blog-pic-1256696029.cos.ap-guangzhou.myqcloud.com/%E8%A1%A8%E6%83%85%E5%8C%85/%E5%91%8A%E8%BE%9E.jpg)\n\n\n\n\n"}]