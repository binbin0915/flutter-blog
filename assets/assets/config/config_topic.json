[{"articleName":"无重复字符的最长子串(中等)","createTime":"2020-01-31T09:56:00.000","lastModifiedTime":"2020-01-31T09:56:00.000","tag":"","summary":" 题目描述\n\n给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。\n\n**示","imageAddress":"","articleAddress":"/config/topic/无重复字符的最长子串(中等).md","articleContent":"## 题目描述\n\n给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。\n\n**示例 1:**\n\n\n```\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n\n**示例 2:**\n\n\n```\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n**示例 3:**\n\n```\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n\n## 解题思路\n\n**滑动窗口**\n\n先简单用图片看一下滑动窗口的概念\n\n![image](https://user-images.githubusercontent.com/30992818/68823336-6d991500-06ce-11ea-916f-20f3abfb3f40.png)\n\n比如上面字符串 ``abcdeabcdfgaee`` 首先进入这个队列， ``abcde`` 是满足题目的，但是再往后 ``abcdea`` 就重复了，所以窗口需要进行移动。\n\n只需要将窗口最左边的元素移出，然后窗口一直往右边移动，知道找到最长的窗口即可。\n\n\n## 答案\n\n\n```\n    fun lengthOfLongestSubstring(s: String): Int {\n        val set = mutableSetOf<Char>()\n        var right = 0\n        var left = 0\n        val n = s.length\n        var lenght = 0\n        while (right < n && left < n){\n            if(!set.contains(s[right])){\n                set.add(s[right])\n                right++\n                lenght = maxOf(lenght, right - left)\n            } else {\n                set.remove(s[left])\n                left++\n            }\n        }\n        return lenght\n    }\n```\n"},{"articleName":"最长回文子串(中等)","createTime":"2020-01-31T09:55:56.000","lastModifiedTime":"2020-01-31T09:55:56.000","tag":"","summary":" 题目描述\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 10","imageAddress":"","articleAddress":"/config/topic/最长回文子串(中等).md","articleContent":"## 题目描述\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n**示例 1：**\n\n\n```\n输入: \"babad\"\n输出: \"bab\"\n注意: \"aba\" 也是一个有效答案。\n```\n\n**示例 2：**\n\n\n```\n输入: \"cbbd\"\n输出: \"bb\"\n```\n\n## 解题思路\n\n根据回文数的特性。当字符串个数为奇数个，比如 ``a`` 是一个回文数。当字符串个数为偶数个，比如  ``aa`` 也是一个回文数。\n\n所以我们要着回文数时，要分两种情况来找\n\n如何找呢？依赖于上面提到的，回文数的特性，通过 由中间向两边扩散的方法来寻找\n\n## 答案\n\n\n```\nclass Solution {\n    fun longestPalindrome(s: String): String {\n        if(s.length <= 1) return s\n        var max = \"\"\n        for (i in 0 until (s.length - 1)) {\n            val one = getPalindrome(s, i,i)\n            val two = getPalindrome(s, i,i+1)\n            val bigger = if(one.length > two.length) one else two\n            max = if(max.length > bigger.length) max else bigger\n        }\n        return max\n    }\n\n    private fun getPalindrome(s: String, left: Int, right: Int) : String{\n        var l = left\n        var r = right\n        var isPalindrome = false\n        while (l >= 0 && r < s.length && s[l] == s[r]){\n            l--\n            r++\n            isPalindrome = true\n        }\n        return if(isPalindrome) s.substring(l+1,r) else s.substring(l, l+1)\n    }\n}\n```\n"},{"articleName":"Z字型变换(中等)","createTime":"2020-01-31T09:55:50.000","lastModifiedTime":"2020-01-31T09:55:50.000","tag":"","summary":" 题目描述\n\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行Z 字形排列。\n\n比如输入","imageAddress":"","articleAddress":"/config/topic/Z字型变换(中等).md","articleContent":"## 题目描述\n\n将一个给定字符串根据给定的行数，以从上往下、从左到右进行Z 字形排列。\n\n比如输入字符串为 ``\"LEETCODEISHIRING\"`` 行数为 3 时，排列如下：\n\n\n```\nL   C   I   R\nE T O E S I I G\nE   D   H   N\n```\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：``\"LCIRETOESIIGEDHN\"``。\n\n请你实现这个将字符串进行指定行数变换的函数：\n\n\n```\nstring convert(string s, int numRows);\n```\n\n\n**示例1:**\n\n\n```\n输入: s = \"LEETCODEISHIRING\", numRows = 3\n输出: \"LCIRETOESIIGEDHN\"\n```\n\n\n**示例2:**\n\n\n```\n输入: s = \"LEETCODEISHIRING\", numRows = 4\n输出: \"LDREOEIIECIHNTSG\"\n解释:\n\nL     D     R\nE   O E   I I\nE C   I H   N\nT     S     G\n```\n\n\n## 解题思路\n\n说实话，这题没有什么特别的解体思路。因为思路上来说解决这道题目很简单。\n\n那为什么我要将这题记录下来呢？\n\n主要做完题目后对比答案，被答案的解法给惊艳到了。这种感觉于我而言就像直接吃掉第六个烧饼，然后肚子就饱了。\n\n答案的解法可读性也不强，但是这种恰到好处的代码甚至让我怀疑出题者是先想到答案，再想到题目的。\n\n## 答案\n\n\n```\nclass Solution {\n    public String convert(String s, int numRows) {\n\n        if (numRows == 1) return s;\n\n        List<StringBuilder> rows = new ArrayList<>();\n        for (int i = 0; i < Math.min(numRows, s.length()); i++)\n            rows.add(new StringBuilder());\n\n        int curRow = 0;\n        boolean goingDown = false;\n\n        for (char c : s.toCharArray()) {\n            rows.get(curRow).append(c);\n            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n            curRow += goingDown ? 1 : -1;\n        }\n\n        StringBuilder ret = new StringBuilder();\n        for (StringBuilder row : rows) ret.append(row);\n        return ret.toString();\n    }\n}\n\n```\n"},{"articleName":"盛最多水的容器(中等)","createTime":"2020-01-31T09:55:47.000","lastModifiedTime":"2020-01-31T09:55:47.000","tag":"","summary":" 题目描述\n\n给定 *n* 个非负整数 *a1，a2，...，an*，每个数代表坐标中的一个点 ","imageAddress":"","articleAddress":"/config/topic/盛最多水的容器(中等).md","articleContent":"## 题目描述\n\n给定 *n* 个非负整数 *a1，a2，...，an*，每个数代表坐标中的一个点 *(i, ai) *。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 *(i, ai)* 和 *(i, 0)*。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。\n\n说明：你不能倾斜容器，且 *n* 的值至少为 2。\n\n![image](https://user-images.githubusercontent.com/30992818/69030923-d60c2d00-0a13-11ea-8924-cb7038f9e194.jpg)\n\n图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n \n \n\n\n**示例:**\n\n\n```\n输入: [1,8,6,2,5,4,8,3,7]\n输出: 49\n```\n\n\n## 解题思路\n\n\n#### 常规思路\n\n直接使用两个for循环，完全遍历，求出最大面积\n\n\n#### 优化思路\n\n**双指针**\n\n直接同时从数组两端开始进行查询。其中值较小的指针向另外一方进行移动。\n\n因为决定面积的除了和两指针中最小的一个值有关，还与两指针的距离有关。\n\n如果移动的是数值更大的指针，那样面积是否增加就无法确定了，而移动数值较小的那个指针可以保证面积是有机会增加的。\n\n## 答案\n\n#### 常规答案\n\n\n```\nclass Solution {\n    fun maxArea(height: IntArray): Int {\n        var maxArea = 0\n        for(i in 0 until height.size - 1){\n            for(j in i+1 until  height.size){\n                val area = minOf(height[i],height[j]) * (j - i)\n                if(maxArea < area){\n                    maxArea = area\n                }\n            }\n        }\n        return maxArea\n    }\n}\n```\n\n\n#### 优化答案\n\n\n```\nclass Solution {\n    fun maxArea(height: IntArray): Int {\n        var left = 0\n        var right = height.size - 1\n        var maxArea = 0\n        while (left < right){\n            val area = minOf(height[left],height[right]) * (right - left)\n            if(maxArea < area){\n                maxArea = area\n            }\n            if(height[left] < height[right]){\n                left++\n            } else {\n                right--\n            }\n        }\n        return maxArea\n    }\n}\n```\n\n\n"},{"articleName":"电话号码的字母组合(中等)","createTime":"2020-01-31T09:55:43.000","lastModifiedTime":"2020-01-31T09:55:43.000","tag":"","summary":" 题目描述\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n\n给出数字到字","imageAddress":"","articleAddress":"/config/topic/电话号码的字母组合(中等).md","articleContent":"## 题目描述\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n![17_telephone_keypad](https://user-images.githubusercontent.com/30992818/69221490-5cf70c00-0bb2-11ea-8db6-d26e80434f31.png)\n\n\n**示例:**\n\n\n```\n输入：\"23\"\n输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\n```\n\n**说明:**  \n尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。\n\n\n\n## 解题思路\n\n#### 回溯\n\n这个题目算是我第一次遇到回溯。关于“回溯”，概念如下：\n\n> 回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。\n\n和递归的不同之处在于，递归会有一个明显的退出条件，用于结束递归循环。而回溯虽然也是一种循环，但是不需要结束条件，走到最后自然就结束了\n\n## 答案\n\n\n```\nclass Solution {\n    fun letterCombinations(digits: String): List<String> {\n        if (digits.isEmpty()) return listOf()\n        val map = mapOf(\n            \"2\" to \"abc\", \"3\" to \"def\",\n            \"4\" to \"ghi\", \"5\" to \"jkl\", \"6\" to \"mno\",\n            \"7\" to \"pqrs\", \"8\" to \"tuv\", \"9\" to \"wxyz\"\n        )\n        val result = mutableListOf<String>()\n        backtrackLetter(\"\", digits, result,map)\n        return result\n    }\n\n    private fun backtrackLetter(\n        combination: String,\n        nextDigit: String,\n        result: MutableList<String>,\n        map: Map<String, String>\n    ) {\n        if (nextDigit.isEmpty()) {\n            result.add(combination)\n        } else {\n            val digit = nextDigit[0].toString()\n            val letters = map[digit] ?: \"\"\n            for (letter in letters) {\n                backtrackLetter(combination + letter, nextDigit.substring(1), result, map)\n            }\n        }\n    }\n}\n```\n"},{"articleName":"三数之和(中等)","createTime":"2020-01-31T09:55:38.000","lastModifiedTime":"2020-01-31T09:55:38.000","tag":"","summary":" 题目描述\n\n给定一个包含 n 个整数的数组 ``nums``，判断 ``nums`` 中是否存","imageAddress":"","articleAddress":"/config/topic/三数之和(中等).md","articleContent":"## 题目描述\n\n给定一个包含 n 个整数的数组 ``nums``，判断 ``nums`` 中是否存在三个元素 *a，b，c* ，使得 *a + b + c = 0* ？找出所有满足条件且不重复的三元组。\n\n**注意**：答案中不可以包含重复的三元组。\n\n\n```\n例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n```\n\n\n## 解题思路\n\n#### 排序+双指针\n\n解决此题的思路的要点就是如何避免重复选择。所以需要用到排序，而双指针则可以加快选择\n\n## 答案\n\n\n```\nclass Solution {\n    fun threeSum(nums: IntArray): List<List<Int>> {\n        nums.sort()\n        val resultList = mutableListOf<List<Int>>()\n        for (i in 0 until nums.size - 2) {\n            if(nums[i] > 0) break\n            var left = i+1\n            var right = nums.size - 1\n            while (left < right){\n                val lv = nums[left]\n                val rv = nums[right]\n                val mv = nums[i]\n                val sum = lv + rv + mv\n                when {\n                    sum == 0 -> {\n                        val list = listOf(lv,mv,rv)\n                        if(!resultList.contains(list)) resultList.add(list)\n                        left++\n                        right--\n                    }\n                    sum < 0 -> left++\n                    else -> right--\n                }\n            }\n        }\n        return resultList\n    }\n}\n```\n\n\n"},{"articleName":"四数之和(中等)","createTime":"2020-01-31T09:55:35.000","lastModifiedTime":"2020-01-31T09:55:35.000","tag":"","summary":" 题目描述\n\n给定一个包含 *n* 个整数的数组 ``nums`` 和一个目标值 ``targe","imageAddress":"","articleAddress":"/config/topic/四数之和(中等).md","articleContent":"## 题目描述\n\n给定一个包含 *n* 个整数的数组 ``nums`` 和一个目标值 ``target``，判断 ``nums`` 中是否存在四个元素 *a，b，c* 和 *d* ，使得 *a + b + c + d* 的值与 ``target`` 相等？找出所有满足条件且不重复的四元组。\n\n**注意：**\n\n答案中不可以包含重复的四元组。\n\n**示例：**\n\n\n```\n给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。\n\n满足要求的四元组集合为：\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n```\n\n\n## 解题思路\n\n可以参考 [三数之和](https://github.com/asjqkkkk/leecode-sample/blob/master/leecode-normal/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C(%E4%B8%AD%E7%AD%89).md) 的解法\n\n四数之和无非是在 **排序** 和 **双指针** 的前提下多加了一次for循环\n\n## 答案\n\n\n```\nclass Solution {\n    fun fourSum(nums: IntArray, target: Int): List<List<Int>> {\n        nums.sort()\n        if(nums.size < 4) return listOf()\n        if(nums.size == 4) return if(nums.sum() == target) listOf(nums.toList()) else listOf()\n        val resultList = mutableListOf<List<Int>>()\n        for (i in 0 until nums.size - 3) {\n            for(j in i+1 until nums.size - 2){\n                var mid = j + 1\n                var right = nums.size - 1\n                while (mid < right) {\n                    val mv = nums[mid]\n                    val rv = nums[right]\n                    val lv2 = nums[j]\n                    val lv = nums[i]\n                    val sum = lv + rv + mv + lv2\n                    when {\n                        sum == target -> {\n                            val list = listOf(lv, mv, rv,lv2)\n                            if (!resultList.contains(list)) resultList.add(list)\n                            mid++\n                            right--\n                        }\n                        sum < target -> mid++\n                        else -> right--\n                    }\n                }\n            }\n\n        }\n        return resultList\n    }\n}\n```\n"},{"articleName":"括号生成(中等)","createTime":"2020-01-31T09:55:31.000","lastModifiedTime":"2020-01-31T09:55:31.000","tag":"","summary":" 题目描述\n\n给出 *n* 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效","imageAddress":"","articleAddress":"/config/topic/括号生成(中等).md","articleContent":"## 题目描述\n\n给出 *n* 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。\n\n例如，给出 *n = 3*，生成结果为：\n\n\n```\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n```\n\n## 解题思路\n\n这种，求多种可能性的。一般都是使用 **回溯** 来解决问题\n\n不过难点在于，回溯的代码要如何写。\n\n首先，可以肯定的是，最左边的一定是左括号，最右边的一定是又括号，而且两者的数量是一致的。\n\n所以，我们可以首先在字符串中放置一个左括号，当右括号数量比左括号数量小时，我们可以放一个右括号。而左括号数量还没达到字符串一半时，我们随时可以放左括号。\n\n## 答案\n\n\n```\nclass Solution {\n    fun generateParenthesis(n: Int): List<String> {\n        val result = mutableListOf<String>()\n        backtraceParenthesis(\"\",0,0,n,result)\n        return result\n    }\n\n    private fun backtraceParenthesis(parenthesis: String, leftNum: Int, rightNum: Int, n: Int, result: MutableList<String>){\n        if(parenthesis.length == n * 2){\n            result.add(parenthesis)\n            return\n        }\n        if(leftNum < n){\n            backtraceParenthesis(\"$parenthesis(\",leftNum+1,rightNum,n,result)\n        }\n        if(rightNum < leftNum){\n            backtraceParenthesis(\"$parenthesis)\",leftNum,rightNum+1,n,result)\n        }\n    }\n}\n```\n"},{"articleName":"两数相除(中等)","createTime":"2020-01-31T09:55:26.000","lastModifiedTime":"2020-01-31T09:55:26.000","tag":"","summary":" 题目描述\n\n给定两个整数，被除数``dividend``和除数``divisor``。将两数相","imageAddress":"","articleAddress":"/config/topic/两数相除(中等).md","articleContent":"## 题目描述\n\n给定两个整数，被除数``dividend``和除数``divisor``。将两数相除，要求不使用乘法、除法和 mod 运算符。\n\n返回被除数``dividend``除以除数``divisor``得到的商。\n \n**示例 1:**\n\n\n```\n输入: dividend = 10, divisor = 3\n输出: 3\n```\n\n**示例 2:**\n\n\n```\n输入: dividend = 7, divisor = -3\n输出: -2\n```\n\n**说明:**\n\n- 被除数和除数均为 32 位有符号整数。\n- 除数不为 0。\n- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。\n\n\n## 解题思路\n\n由于不能使用乘法与除法之类的操作。\n\n最简单的办法就是循环使用被除数减去除数，直到被除数小于除数为止。\n\n但是很明显，这样的方法耗时过多。所以并不推荐这种办法\n\n看一下除法的公式：\n\n```\na = mb + n\n\n其中 a 为被除数，b 为除数，m 为商，n 为余数\n```\n我们可以把公式转换一下：\n\n\n```\na - (m-1)b = b + n\n```\n这样看其实只要把 ``除数b`` 一直翻倍，直到再翻一倍就比 ``被除数a`` 大,这时候通过后者与前者的 ``差值`` ，再去求商即可。\n\n那么如何在不使用乘法的情况下对除数翻倍呢？答案就是移位！\n\n## 答案\n\n\n```\nclass Solution {\n    fun divide(dividend: Int, divisor: Int): Int {\n        var dividendNum = dividend\n        var divisorNum = divisor\n        val sign = (dividendNum > 0) xor (divisorNum > 0)\n        var result = 0\n        if (dividendNum > 0) {\n            dividendNum = -dividendNum\n        }\n        if (divisorNum > 0) divisorNum = -divisorNum\n        while (dividendNum <= divisorNum) {\n            var tempResult = -1\n            var tempDivisor = divisorNum\n            while (dividendNum <= tempDivisor shl 1) {\n                if (tempDivisor <= Integer.MIN_VALUE shr 1) break\n                tempResult = tempResult shl 1\n                tempDivisor = tempDivisor shl 1\n            }\n            dividendNum -= tempDivisor\n            result += tempResult\n        }\n        if (!sign) {\n            if (result <= Integer.MIN_VALUE) return Integer.MAX_VALUE\n            result = -result\n        }\n        return result\n    }\n}\n```\n\n\n\n"},{"articleName":"在排序数组中查找元素的第一个和最后一个位置(中等)","createTime":"2020-01-31T09:55:22.000","lastModifiedTime":"2020-01-31T09:55:22.000","tag":"","summary":" 题目描述\n\n给定一个按照升序排列的整数数组 ``nums``，和一个目标值 ``target`","imageAddress":"","articleAddress":"/config/topic/在排序数组中查找元素的第一个和最后一个位置(中等).md","articleContent":"## 题目描述\n\n给定一个按照升序排列的整数数组 ``nums``，和一个目标值 ``target``。找出给定目标值在数组中的开始位置和结束位置。\n\n你的算法时间复杂度必须是 *O(log n)* 级别。\n\n如果数组中不存在目标值，返回 ``[-1, -1]``。\n\n**示例 1:**\n\n\n```\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: [3,4]\n```\n\n**示例 2:**\n\n\n```\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: [-1,-1]\n```\n\n## 解题思路\n\n**二分查找法**\n\n二分查找法不必多说\n\n## 答案\n\n\n```\nclass Solution {\n    fun searchRange(nums: IntArray, target: Int): IntArray {\n        var result = intArrayOf(-1,-1)\n        val leftIdx = binarySearchLeftIndex(nums,target,true)\n        if (leftIdx >= nums.size || nums[leftIdx] != target) {\n            return result\n        }\n        result[0] = leftIdx\n        result[1] = binarySearchLeftIndex(nums,target,false)-1\n        return result\n    }\n\n    private fun binarySearchLeftIndex(nums: IntArray,tartget: Int,isLeft: Boolean) : Int {\n        var start = 0\n        var end = nums.size\n        while (start < end) {\n            var mid = start + (end - start) / 2\n            if (nums[mid] > tartget || (isLeft && nums[mid] == tartget)) {\n                end = mid\n            } else {\n                start = mid + 1\n            }\n        }\n        return start\n    }\n}\n```\n"},{"articleName":"全排列 II(中等)","createTime":"2020-01-31T09:55:18.000","lastModifiedTime":"2020-01-31T09:55:18.000","tag":"","summary":" 题目描述\n\n给定一个可包含重复数字的序列，返回所有不重复的全排列。\n\n**示例:**\n\n\n``","imageAddress":"","articleAddress":"/config/topic/全排列 II(中等).md","articleContent":"## 题目描述\n\n给定一个可包含重复数字的序列，返回所有不重复的全排列。\n\n**示例:**\n\n\n```\n输入: [1,1,2]\n输出:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n\n\n## 解题思路\n\n这题是 [全排列](https://leetcode-cn.com/problems/permutations/) 的进阶版，具体的改动就是，由不包含重复的输入序列变成了可包含重复的数字序列。\n\n显然，出了需要使用回溯外，还需要进行剪枝才行。这题的难点就是如何去写剪枝的逻辑了。\n\n先看看不减枝的常规解法：\n\n#### 一般思路：\n\n通过Set的特性，来完成去重操作，不过这样耗时会高很多。\n\n#### 优化思路：\n\nleecode上面有非常好的思路，下面将其放上：\n\n\n<img width=\"500\" alt=\"WeChatcf0b8272848f0486837568e93d4607e7\" src=\"https://user-images.githubusercontent.com/30992818/71465127-aa404c00-27f6-11ea-9979-43c572364b7a.png\">\n\n\n<img width=\"500\" alt=\"https://user-images.githubusercontent.com/30992818/71465153-c04e0c80-27f6-11ea-9427-acd5d30f7460.png\">\n\n<img width=\"500\" alt=\"https://user-images.githubusercontent.com/30992818/71465188-dbb91780-27f6-11ea-9b8d-7e4003484fed.png\">\n\n<img width=\"500\" alt=\"https://user-images.githubusercontent.com/30992818/71465247-ff7c5d80-27f6-11ea-9cee-c5dfb0d47f39.png\">\n\n\n\n## 答案\n\n#### 一般答案\n\n\n```\n    fun permute(nums: IntArray): List<List<Int>> {\n        val result = mutableListOf<List<Int>>()\n        for (i in nums.indices) {\n            val newNumbs = nums.toMutableList()\n            newNumbs.removeAt(i)\n            traceBackPermute(newNumbs, mutableListOf(nums[i]), result)\n        }\n        return result\n    }\n\n    private fun traceBackPermute(\n        numbs: List<Int>,\n        currentList: MutableList<Int>,\n        result: MutableList<List<Int>>\n    ) {\n        if (numbs.isEmpty()) {\n            val list = mutableListOf<Int>()\n            list.addAll(currentList)\n            if (!result.contains(list)) result.add(list)\n            return\n        }\n        for (i in numbs.indices) {\n            val newNumbs = numbs.toMutableList()\n            newNumbs.removeAt(i)\n            currentList.add(numbs[i])\n            traceBackPermute(newNumbs, currentList, result)\n            currentList.remove(currentList.last())\n        }\n    }\n```\n\n#### 优化答案\n\n\n```\n fun permuteUnique(nums: IntArray): List<List<Int>> {\n        val result = mutableListOf<List<Int>>()\n        nums.sort()\n        traceBackPermuteUnique(nums, MutableList(nums.size) {false},0, mutableListOf(),result)\n        return result.toList()\n    }\n\n    private fun traceBackPermuteUnique(nums: IntArray,\n                                        usedList: MutableList<Boolean>,\n                                        currentIndex: Int,\n                                        currentList: MutableList<Int>,\n                                        result: MutableList<List<Int>>){\n        if(currentIndex == nums.size) {\n            val list = mutableListOf<Int>()\n            list.addAll(currentList)\n            result.add(list)\n        }\n        for (i in nums.indices) {\n            if(usedList[i]) continue\n            // 与上一个数相等,并且上一个数使用过，则数据重复,不加入集合（数据相同，只出一个排列结果）\n            if (i > 0 && nums[i] == nums[i - 1] && usedList[i - 1]) continue\n            usedList[i] = true\n            currentList.add(nums[i])\n            traceBackPermuteUnique(nums,usedList, currentIndex+1,currentList,result)\n            currentList.removeAt(currentList.size - 1)\n            usedList[i] = false\n        }\n    }\n```\n"},{"articleName":"Pow(x,n)  (中等)","createTime":"2020-01-31T09:55:13.000","lastModifiedTime":"2020-01-31T09:55:13.000","tag":"","summary":" 题目描述\n\n实现 ``pow(x, n)`` ，即计算 x 的 n 次幂函数。\n\n**示例 1","imageAddress":"","articleAddress":"/config/topic/Pow(x,n)  (中等).md","articleContent":"## 题目描述\n\n实现 ``pow(x, n)`` ，即计算 x 的 n 次幂函数。\n\n**示例 1:**\n\n\n```\n输入: 2.00000, 10\n输出: 1024.00000\n```\n\n**示例 2:**\n\n\n```\n输入: 2.10000, 3\n输出: 9.26100\n```\n\n**示例 3:**\n\n\n```\n输入: 2.00000, -2\n输出: 0.25000\n解释: 2-2 = 1/22 = 1/4 = 0.25\n```\n\n**说明:**\n\n- -100.0 < ``x`` < 100.0\n- ``n`` 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。\n\n\n## 解题思路\n\n最简单粗暴的办法去计算x的n次方，就是将x循环乘以n次。但是显而易见，这样当n非常大的时候计算次数会非常多。\n\n换一个思路，如果我们用折半的方法去缩小循环的次数呢？\n\n## 答案\n\n\n```\n    fun myPow(x: Double, n: Int): Double {\n        var result = 1.0\n        var num = x\n        var i = n\n        while (i != 0) {\n            if (i % 2 != 0) {\n                result *= num\n            }\n            num *= num\n            i /= 2\n        }\n        return if (n < 0) 1 / result else result\n    }\n```\n"},{"articleName":"字符串相乘(中等)","createTime":"2020-01-31T09:55:10.000","lastModifiedTime":"2020-01-31T09:55:10.000","tag":"","summary":" 题目描述\n\n给定两个以字符串形式表示的非负整数 ``num1`` 和 ``num2``，返回 ","imageAddress":"","articleAddress":"/config/topic/字符串相乘(中等).md","articleContent":"## 题目描述\n\n给定两个以字符串形式表示的非负整数 ``num1`` 和 ``num2``，返回 ``num1`` 和 ``num2`` 的乘积，它们的乘积也表示为字符串形式。\n\n**示例 1:**\n\n```\n输入: num1 = \"2\", num2 = \"3\"\n输出: \"6\"\n```\n**示例 2:**\n\n\n```\n输入: num1 = \"123\", num2 = \"456\"\n输出: \"56088\"\n```\n**说明：**\n\n- ``num1``  和 ``num2`` 的长度小于110。\n- ``num1`` 和 ``num2`` 只包含数字 ``0-9``。\n- ``num1`` 和 ``num2`` 均不以零开头，除非是数字 ``0`` 本身。\n- **不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。**\n\n\n## 解题思路\n\n可以通过小学学过的，**竖式相乘** 来进行求解\n\n![image](https://user-images.githubusercontent.com/30992818/72044806-b85e9400-32ef-11ea-8c97-f0e12b4f9c2d.png)\n\n结合图片来看：\n\n- 如果乘数 ``num1`` 位数为 ``M``，被乘数 ``num2`` 位数为 ``N``， 那么 ``num1 x num2`` 结果 ``res`` 最大总位数为 **``M+N``**\n- 根据上面的信息，如果以字符串的形式表示的话，``num1`` 长度为 ``M``，``num2`` 长度为 ``N``，``res`` 长度为 ``M+N``\n- ``num1[i] x num2[j]`` 的结果为 ``tmp``(位数为两位，\"0x\",\"xy\"的形式)，其第一位位于 ``res[i+j]``，第二位位于 ``res[i+j+1]``\n\n\n根据上面的信息，其实就可以写出题解了\n\n\n## 答案\n\n\n```\n    fun multiply(num1: String, num2: String): String {\n        if(num1 ==\"0\" || num2 == \"0\") return \"0\"\n        val array = IntArray(num1.length + num2.length)\n        for (i in (num1.length - 1) downTo 0) {\n            val n1 = num1[i] - '0'\n            for (j in (num2.length - 1) downTo 0){\n                val n2 = num2[j] - '0'\n                val sum = array[i + j + 1] + n1 * n2\n                array[i + j + 1] = sum % 10\n                array[i + j] += sum / 10\n            }\n        }\n        val result = StringBuilder()\n        for (i in array.indices) {\n            if(i == 0 && array[i] == 0) continue\n            result.append(array[i])\n        }\n        return result.toString()\n    }\n```\n"},{"articleName":"旋转图像(中等)","createTime":"2020-01-31T09:55:06.000","lastModifiedTime":"2020-01-31T09:55:06.000","tag":"","summary":" 题目描述\n\n给定一个 *``n × n``* 的二维矩阵表示一个图像。\n\n将图像顺时针旋转 9","imageAddress":"","articleAddress":"/config/topic/旋转图像(中等).md","articleContent":"## 题目描述\n\n给定一个 *``n × n``* 的二维矩阵表示一个图像。\n\n将图像顺时针旋转 90 度。\n\n**说明：**\n\n你必须在**原地**旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。\n\n**示例 1:**\n\n\n```\n给定 matrix = \n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\n原地旋转输入矩阵，使其变为:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n```\n**示例 2:**\n\n\n```\n给定 matrix =\n[\n  [ 5, 1, 9,11],\n  [ 2, 4, 8,10],\n  [13, 3, 6, 7],\n  [15,14,12,16]\n], \n\n原地旋转输入矩阵，使其变为:\n[\n  [15,13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7,10,11]\n]\n```\n\n\n## 解题思路\n\n可以换一个角度来看问题，比如我们不是直接去旋转数组，而是每次先旋转数组的 **上下左右** 四个角。\n\n接着，旋转数组四个角相邻的元素，直到该层旋转完毕。然后开始里面一层的旋转。\n\n因为是顺时针旋转，所以旋转方向是 ``左上角 -> 向右``，``右上角 -> 向下``，``右下角 -> 向左``，``左下角 -> 向上``。\n\n不过理论上是如此，实际写代码的时候还需要仔细一些，因为一不小心可能就会写错元素对应的下标\n\n## 答案\n\n\n```\n    fun rotate(matrix: Array<IntArray>): Unit {\n        val n = matrix.size\n        for(i in 0 until n / 2){\n            for(j in i until (n - i - 1)){\n                val start = matrix[i][j]\n                matrix[i][j] = matrix[n-j-1][i]\n                matrix[n-j-1][i] = matrix[n-i-1][n-j-1]\n                matrix[n-i-1][n-j-1] = matrix[j][n-i-1]\n                matrix[j][n-i-1] = start\n            }\n        }\n    }\n```\n"},{"articleName":"螺旋矩阵(中等)","createTime":"2020-01-31T09:55:02.000","lastModifiedTime":"2020-01-31T09:55:02.000","tag":"","summary":" 题目描述\n\n给定一个包含 *m x n* 个元素的矩阵（*m* 行, *n* 列），请按照顺时","imageAddress":"","articleAddress":"/config/topic/螺旋矩阵(中等).md","articleContent":"## 题目描述\n\n给定一个包含 *m x n* 个元素的矩阵（*m* 行, *n* 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。\n\n**示例 1:**\n\n\n```\n输入:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n输出: [1,2,3,6,9,8,7,4,5]\n```\n\n**示例 2:**\n\n\n```\n输入:\n[\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9,10,11,12]\n]\n输出: [1,2,3,4,8,12,11,10,9,5,6,7]\n```\n\n## 解题思路\n\n直接按层模拟\n\n![image](https://user-images.githubusercontent.com/30992818/72047846-6a00c380-32f6-11ea-9f99-cd266565ad32.png)\n\n\n顺时针来进行输出，一层输出完后进入里层继续输出，知道全部输出完毕\n\n## 答案\n\n\n```\n    fun spiralOrder(matrix: Array<IntArray>): List<Int> {\n        val result = mutableListOf<Int>()\n        if (matrix.isEmpty()) return result\n        var left = 0\n        var right = matrix[0].size - 1\n        var top = 0\n        var bottom = matrix.size - 1\n        while (left <= right && top <= bottom) {\n            for(i in left..right){\n                result.add(matrix[top][i])\n            }\n            for(i in top+1..bottom){\n                result.add(matrix[i][right])\n            }\n            if (left < right && top < bottom) {\n                for(i in right-1 downTo left+1){\n                    result.add(matrix[bottom][i])\n                }\n                for(i in bottom downTo top+1){\n                    result.add(matrix[i][left])\n                }\n            }\n            left++\n            right--\n            top++\n            bottom--\n        }\n        return result\n    }\n```\n"},{"articleName":"跳跃游戏(中等)","createTime":"2020-01-31T09:54:56.000","lastModifiedTime":"2020-01-31T09:54:56.000","tag":"","summary":" 题目描述\n\n给定一个非负整数数组，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位","imageAddress":"","articleAddress":"/config/topic/跳跃游戏(中等).md","articleContent":"## 题目描述\n\n给定一个非负整数数组，你最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个位置。\n\n**示例 1:**\n\n\n```\n输入: [2,3,1,1,4]\n输出: true\n解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。\n```\n\n**示例 2:**\n\n\n```\n输入: [3,2,1,0,4]\n输出: false\n解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。\n```\n\n## 解题思路\n\n\n- 如果某一个作为 起跳点 的格子可以跳跃的距离是3，那么表示后面3个格子都可以作为 起跳点。\n- 可以对每一个能作为 起跳点 的格子都尝试跳一次，把能跳到最远的距离不断更新。\n- 如果可以一直跳到最后，就成功了。\n\n## 答案\n\n\n```\n    fun canJump(nums: IntArray): Boolean {\n        var maxStep = 0\n        for (i in nums.indices) {\n            if(i > maxStep) return false\n            maxStep = max(maxStep, nums[i] + i)\n        }\n        return true\n    }\n```\n"},{"articleName":"旋转链表(中等)","createTime":"2020-01-31T09:54:52.000","lastModifiedTime":"2020-01-31T09:54:52.000","tag":"","summary":" 题目描述\n\n给定一个链表，旋转链表，将链表每个节点向右移动 *k* 个位置，其中 *k* 是非","imageAddress":"","articleAddress":"/config/topic/旋转链表(中等).md","articleContent":"## 题目描述\n\n给定一个链表，旋转链表，将链表每个节点向右移动 *k* 个位置，其中 *k* 是非负数。\n\n**示例 1:**\n\n\n```\n输入: 1->2->3->4->5->NULL, k = 2\n输出: 4->5->1->2->3->NULL\n解释:\n向右旋转 1 步: 5->1->2->3->4->NULL\n向右旋转 2 步: 4->5->1->2->3->NULL\n```\n\n**示例 2:**\n\n\n```\n输入: 0->1->2->NULL, k = 4\n输出: 2->0->1->NULL\n解释:\n向右旋转 1 步: 2->0->1->NULL\n向右旋转 2 步: 1->2->0->NULL\n向右旋转 3 步: 0->1->2->NULL\n向右旋转 4 步: 2->0->1->NULL\n```\n\n## 解题思路\n\n这题的难点主要在于，k的大小可能超过链表的长度。所以需要先计算出链表的长度，也就是先遍历一遍链表。\n\n这题可以在第一次遍历链表后，将链表首尾相连，然后可以在第二次遍历时，将链表旋转\n\n![image](https://user-images.githubusercontent.com/30992818/72131149-65034900-33b6-11ea-8bd7-e96a1a6a7f99.png)\n\n\n## 答案\n\n\n```\n    fun rotateRight(head: ListNode?, k: Int): ListNode? {\n        if(head == null || k == 0) return head\n        var index = 0\n        var temp = head\n        while (temp != null){\n            index++\n            if(temp.next == null){\n                temp.next = head\n                break\n            }\n            temp = temp.next\n        }\n        val realK = k % index\n        if(realK == 0 || realK == index) {\n            temp?.next = null\n            return head\n        }\n        var temp2 = temp\n        var index2 = 0\n        var result :ListNode ?= null\n        while (temp2!!.next != null){\n            index2++\n            temp2 = temp2.next\n            if(index2 == index - realK){\n                result = temp2?.next\n                temp2?.next = null\n                break\n            }\n        }\n        return result\n    }\n```\n"},{"articleName":"不同路径(中等)","createTime":"2020-01-31T09:54:49.000","lastModifiedTime":"2020-01-31T09:54:49.000","tag":"","summary":" 题目描述\n\n一个机器人位于一个 *m x n* 网格的左上角 （起始点在下图中标记为“Star","imageAddress":"","articleAddress":"/config/topic/不同路径(中等).md","articleContent":"## 题目描述\n\n一个机器人位于一个 *m x n* 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n\n![image](https://user-images.githubusercontent.com/30992818/72131874-76e5eb80-33b8-11ea-8cb9-a6cc28b18d9a.png)\n\n\n例如，上图是一个7 x 3 的网格。有多少可能的路径？\n\n**说明**：m 和 n 的值均不超过 100。\n\n**示例 1:**\n\n\n```\n输入: m = 3, n = 2\n输出: 3\n解释:\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向右 -> 向下\n2. 向右 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向右\n```\n\n**示例 2:**\n\n\n```\n输入: m = 7, n = 3\n输出: 28\n```\n\n## 解题思路\n\n这题涉及到 **动态规划** 的概念。\n\n由于机器人只能 **向右** 或者 **向下** 移动，如果我们以dp[i][j]表示机器人到达第i行第j列的路径数和。那么可以很容易得到：\n\n    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n> 对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1\n\n![image](https://user-images.githubusercontent.com/30992818/72132900-14dab580-33bb-11ea-98af-a091211702af.png)\n\n![image](https://user-images.githubusercontent.com/30992818/72132916-1e641d80-33bb-11ea-830d-70a5d075890e.png)\n\n根据上面的式子，就可以求出所有路径\n\n(本题也可以根据排列组合来求解，不过太简单了，这里就不说了)\n\n## 答案\n\n\n```\n    fun uniquePaths(m: Int, n: Int): Int {\n        val dp = Array(n){IntArray(m)}\n        for (i in 0 until m) {\n            dp[0][i] = 1\n        }\n        for(i in 0 until n){\n            dp[i][0] = 1\n        }\n        for(i in 1 until n){\n            for(j in 1 until m){\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            }\n        }\n        return dp[n-1][m-1]\n    }\n```\n\n**优化版：**\n\n```\n    fun uniquePaths(m: Int, n: Int): Int {\n        val memo = IntArray(n){i -> 1}\n        for (i in 1 until m) {\n            for (j in 1 until n) {\n                memo[j] += memo[j - 1]\n            }\n        }\n        return memo[n - 1]\n    }\n```\n"},{"articleName":"不同路径 II(中等)","createTime":"2020-01-31T09:54:44.000","lastModifiedTime":"2020-01-31T09:54:44.000","tag":"","summary":" 题目描述\n\n一个机器人位于一个 *m x n* 网格的左上角 （起始点在下图中标记为“Star","imageAddress":"","articleAddress":"/config/topic/不同路径 II(中等).md","articleContent":"## 题目描述\n\n一个机器人位于一个 *m x n* 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n![image](https://user-images.githubusercontent.com/30992818/72131874-76e5eb80-33b8-11ea-8cb9-a6cc28b18d9a.png)\n\n网格中的障碍物和空位置分别用 1 和 0 来表示。\n\n**说明**：m 和 n 的值均不超过 100。\n\n**示例 1:**\n\n\n```\n输入:\n[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\n输出: 2\n解释:\n3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 2 条不同的路径：\n1. 向右 -> 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右 -> 向右\n```\n\n\n## 解题思路\n\n这题相较于它的上一个版本来说，多了 **障碍物** 的设置。\n\n如果某个格子上有障碍物，那么我们不考虑包含这个格子的任何路径。也就是说**这个格子提供的路径值为0**。而没有障碍物的格子，提供的路径值为1。\n\n接下来我们还是将上边界和左边界全部设置为1(这里的1和用于表示障碍物的1，虽然数值一样，但是概念不同)，不过这里需要注意几点：\n- 如果第一个点就存在障碍物，那后面的点就都为0了\n- 如果第一个点没有障碍物，将第一个点的值由0设置为1，表示提供一个路径值\n- 遍历第一行，如果存在障碍物，将改点的数值由1设置为0，表示不提供路径值\n- 遍历第一列，与上面一样\n- 从第[1][1]点开始进行遍历，如果发现某个点有障碍物，将其值由1设为0，否则该点的值为左边的点和上边的点的值相加\n\n\n根据以上几点，我们就可以使用**动态规划**来解决问题了\n\n\n## 答案\n\n\n```\n    fun uniquePathsWithObstacles(obstacleGrid: Array<IntArray>): Int {\n        val column = obstacleGrid.size\n        val row = obstacleGrid[0].size\n        if(obstacleGrid[0][0] == 1) return 0\n        obstacleGrid[0][0] = 1\n        for (i in 1 until column) {\n            obstacleGrid[i][0] = if(obstacleGrid[i-1][0] == 1 && obstacleGrid[i][0] == 0) 1 else 0\n        }\n        for(i in 1 until row){\n            obstacleGrid[0][i] = if(obstacleGrid[0][i-1] == 1 && obstacleGrid[0][i] == 0) 1 else 0\n        }\n        for(i in 1 until column){\n            for(j in 1 until row){\n                if(obstacleGrid[i][j] == 1){\n                    obstacleGrid[i][j] = 0\n                } else {\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n                }\n            }\n        }\n        return obstacleGrid[column-1][row-1]\n    }\n```\n"},{"articleName":"最小路径和(中等)","createTime":"2020-01-31T09:54:39.000","lastModifiedTime":"2020-01-31T09:54:39.000","tag":"","summary":" 题目描述\n\n给定一个包含非负整数的 *m x n* 网格，请找出一条从左上角到右下角的路径，使","imageAddress":"","articleAddress":"/config/topic/最小路径和(中等).md","articleContent":"## 题目描述\n\n给定一个包含非负整数的 *m x n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n说明：每次只能向下或者向右移动一步。\n\n**示例:**\n\n\n```\n输入:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。\n```\n\n\n## 解题思路\n\n还是动态规划\n\n- 可以用 **d[i][j]** 表示从 **d[0][0]** 到 **d[i][j]** 的最小距离\n- 对于每个点，该点的值为左边点和上边点中较小的一个与改点想加。如果是左边界或又边界，则少边界上一个点与当前点想加\n\n\n直接看代码，简洁明了\n\n\n## 答案\n\n\n```\n    fun minPathSum(grid: Array<IntArray>): Int {\n        val column = grid.size\n        val row = grid[0].size\n        for(i in 0 until column){\n            for(j in 0 until row){\n                if(i == 0 && j == 0) continue\n                else if(i == 0) grid[i][j] += grid[i][j-1]\n                else if(j == 0) grid[i][j] += grid[i-1][j]\n                else grid[i][j] += min(grid[i-1][j],grid[i][j-1])\n            }\n        }\n        return grid[column-1][row-1]\n    }\n```\n"},{"articleName":"链表随机节点(中等)","createTime":"2020-01-31T09:54:34.000","lastModifiedTime":"2020-01-31T09:54:34.000","tag":"","summary":" 题目描述\n\n给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点**被选的","imageAddress":"","articleAddress":"/config/topic/链表随机节点(中等).md","articleContent":"## 题目描述\n\n给定一个单链表，随机选择链表的一个节点，并返回相应的节点值。保证每个节点**被选的概率一样**。\n\n**进阶:**\n如果链表十分大且长度未知，如何解决这个问题？你能否使用常数级空间复杂度实现？\n\n**示例:**\n\n\n```\n// 初始化一个单链表 [1,2,3].\nListNode head = new ListNode(1);\nhead.next = new ListNode(2);\nhead.next.next = new ListNode(3);\nSolution solution = new Solution(head);\n\n// getRandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。\nsolution.getRandom();\n```\n\n## 解题思路\n\n这题是一道 **蓄水池抽样** 算法题\n\n关于蓄水池抽样，简单介绍几个例子：\n\n### 问题示例\n\n采样问题经常会被遇到，比如：\n\n- 从 100000 份调查报告中抽取 1000 份进行统计。\n- 从一本很厚的电话簿中抽取 1000 人进行姓氏统计。\n- 从 Google 搜索 \"Ken Thompson\"，从中抽取 100 个结果查看哪些是今年的。\n\n像这样的，**对于输入数据的规模不确定**，但是要求所抽样的对象被抽取的概率一样，这就涉及到了 **蓄水池采样** 算法\n\n### 算法过程\n终于要讲到**蓄水池采样算法**(Reservoir Sampling)了。先说一下算法的过程：\n\n假设数据序列的规模为 *n* ， 需要采样的数量的为 *k* \n\n首先构建一个可容纳 *k* 个元素的数组，将序列的前 *k* 个元素放入数组中\n\n然后从第 *k+1* 个元素开始，以 *k/n* 的概率来决定该元素是否被替换到数组中（数组中的元素被替换的概率是相同的）。当遍历完所有元素之后，数组中剩下的元素即为所需采取的样本。\n\n### 证明过程\n\n对于第 *i* 个数(*i <= k*)。在 *k* 步之前，被选中的概率为 1。走到第 *k+1* 步时，第 *i* 个数被第 *k+1* 个数替换的概率为：\n\n    【第 k+1 个数被选中的概率】 * 【第 i 个数被选中然后替换的概率】\n\n也就是 *k*/(*k+1*) * *1/k* = *1*/(*k+1*)。则第 *i* 个数被保留的概率为 *1* - *1*/(*k+1*) = *k*/(*k+1*)\n\n依此类推，第 *i* 个数不被第 *k+2* 个数替换掉的概率为 1 - *k*/(*k+2*) * *1/k* = *k+1*/(*k+2*)。则走到第 *n* 步时，第 *i* 个数被保留的概率为：\n![image](https://user-images.githubusercontent.com/30992818/72140924-c3d3bd00-33cc-11ea-8e87-0e7a554ba8c4.png)\n\n所以对于其中每个元素，被保留的概率都为 *k/n*\n\n到这里，蓄水池抽样算是证明完毕，接下来，就可以直接使用在代码中了\n\n## 答案\n\n\n```\nimport kotlin.random.Random\n\nclass Solution(head: ListNode?) {\n    \n        private val theHead = head\n        private val random = Random(1)\n\n        fun getRandom(): Int {\n            var num = 1\n            var value = theHead?.`val` ?: 0\n            var next = theHead\n            while (next?.next != null){\n                num++\n                next = next.next\n                val nextValue = next?.`val` ?: 0\n                val randomRate = random.nextDouble()\n                val rate = 1.0 / num\n                val needChanged = randomRate <= rate\n                if(needChanged) value = nextValue\n            }\n            return value\n        }\n\n}\n```\n"},{"articleName":"将有序数组转换为二叉搜索树(简单)","createTime":"2020-01-31T09:54:16.000","lastModifiedTime":"2020-01-31T09:54:16.000","tag":"","summary":" 题目描述\n\n将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。\n\n本题中，一个高度平","imageAddress":"","articleAddress":"/config/topic/将有序数组转换为二叉搜索树(简单).md","articleContent":"## 题目描述\n\n将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n\n**示例:**\n\n\n```\n给定有序数组: [-10,-3,0,5,9],\n\n一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n```\n\n## 解题思路\n\n> 平衡二叉树的一个特性是：左子节点小于父节点，右子节点大于父节点\n\n也就是说，根据这个特性，我们可以想象得到，每一颗平衡二叉树，根节点的值，就是一个有序数组最中间的值。\n\n> 再根据平衡二叉树另外一个特性：每个子节点都可以单独看成一颗新的平衡二叉树的根节点（子树）\n\n两个特性结合，就可以根据二分法来解题了\n\n## 答案\n\n\n```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return sortedArrayToBST(nums, 0, nums.length);\n    }\n    \n    private TreeNode sortedArrayToBST(int[] nums, int start, int end) {\n        if (start >= end) {\n            return null;\n        }\n        int mid = start/2 + end / 2;\n        TreeNode root = new TreeNode(nums[mid]);\n        root.left = sortedArrayToBST(nums, start, mid);\n        root.right = sortedArrayToBST(nums, mid + 1, end);\n        return root;\n    }\n}\n```\n"},{"articleName":"平衡二叉树(简单)","createTime":"2020-01-31T09:54:12.000","lastModifiedTime":"2020-01-31T09:54:12.000","tag":"","summary":" 题目描述\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为","imageAddress":"","articleAddress":"/config/topic/平衡二叉树(简单).md","articleContent":"## 题目描述\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为：\n> 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。\n\n**示例 1:**\n\n给定二叉树 ``[3,9,20,null,null,15,7]``\n\n```\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n返回 ``true`` 。\n\n**示例 2:**\n\n给定二叉树 ``[1,2,2,3,3,null,null,4,4]``\n\n\n```\n       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n```\n返回 ``false`` 。\n\n## 解题思路\n\n由于平衡二叉树**每个节点的左右两个子树**的高度差的绝对值不超过1。\n\n所以我们根据这个特性来，由底到上来对二叉树进行便利，当遇到有左右子树高度相差超过1时候，停止遍历，并且得到结果。这里，用 **-1** 来表示遍历非平衡二叉树，其他数字则表示正常的高度\n\n## 答案\n\n\n```\n/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nimport kotlin.math.abs\nimport kotlin.math.max\nclass Solution {\n    fun isBalanced(root: TreeNode?): Boolean {\n        return treeDeep(root) != -1   \n    }\n    \n    fun treeDeep(root: TreeNode?): Int{\n        if(root == null) return 0\n        val left = treeDeep(root.left)\n        if(left == -1) return -1\n        val right = treeDeep(root.right)\n        if(right == -1) return  -1\n        return if(abs(left - right) < 2) max(left,right) + 1 else -1\n    }\n}\n```\n"},{"articleName":"二叉树的最小深度(简单)","createTime":"2020-01-31T09:54:07.000","lastModifiedTime":"2020-01-31T09:54:07.000","tag":"","summary":" 题目描述\n\n给定一个二叉树，找出其最小深度。\n\n最小深度是从根节点到最近叶子节点的最短路径上的","imageAddress":"","articleAddress":"/config/topic/二叉树的最小深度(简单).md","articleContent":"## 题目描述\n\n给定一个二叉树，找出其最小深度。\n\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n说明: 叶子节点是指没有子节点的节点。\n\n**示例:**\n\n给定二叉树 ``[3,9,20,null,null,15,7]``,\n\n```\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n返回它的最小深度  2.\n\n## 解题思路\n\n参考一下“平衡二叉树（简单）”的解法，自然就知道如何解题了。\n\n通过递归，只返回节点左右子树中高度最小的数值即可\n\n## 答案\n\n\n```\n/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nimport kotlin.math.min\nimport kotlin.math.max\n\nclass Solution {\n    fun minDepth(root: TreeNode?): Int {\n        if(root == null) return 0\n        val left = minDepth(root.left)\n        val right = minDepth(root.right)\n        if(left == 0 || right == 0) return max(left,right) + 1\n        return min(left,right) + 1\n    }\n}\n```\n"},{"articleName":"路径总和(简单)","createTime":"2020-01-31T09:54:02.000","lastModifiedTime":"2020-01-31T09:54:02.000","tag":"","summary":" 题目描述\n\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所","imageAddress":"","articleAddress":"/config/topic/路径总和(简单).md","articleContent":"## 题目描述\n\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\n\n**说明:** 叶子节点是指没有子节点的节点。\n\n**示例:**  \n给定如下二叉树，以及目标和 ``sum = 22``，\n\n\n```\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\n\n```\n返回 ``true``, 因为存在目标和为 22 的根节点到叶子节点的路径 ``5->4->11->2``。\n\n\n## 解题思路\n\n很容易可以看出，这是一个需要遍历二叉树，然后求出每条路径节点值的和。\n\n转换一下思路，如果我们不是求和，而是每经过一个节点，减去该节点的值，直到最后一个节点的时候，得到的值恰好为0。不也正好说明这条路径节点值的和与所给数值相等吗？\n\n## 答案\n\n\n```\n/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun hasPathSum(root: TreeNode?, sum: Int): Boolean {\n        if(root == null) return false\n        val resetSum = sum - root.`val`\n        if(root.left == null && root.right == null) return resetSum == 0\n        return hasPathSum(root.left, resetSum) || hasPathSum(root.right, resetSum)\n    }\n}\n```\n"},{"articleName":"只出现一次的数字(简单)","createTime":"2020-01-31T09:53:56.000","lastModifiedTime":"2020-01-31T09:53:56.000","tag":"","summary":" 题目描述\n\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个","imageAddress":"","articleAddress":"/config/topic/只出现一次的数字(简单).md","articleContent":"## 题目描述\n\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n**说明：**\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n**示例 1:**\n\n\n```\n输入: [2,2,1]\n输出: 1\n```\n\n**示例 2:**\n\n\n```\n输入: [4,1,2,1,2]\n输出: 4\n```\n\n## 解体思路\n\n#### 思路一：\n\n这是常规思路，数组放入Map中，其中key-value不一致的就是那个数字\n\n\n#### 思路二：\n\n这个才是需要重点说明的，巧妙的解题思路。\n\n根据“与或非”的特性。使用异或：相同为0，不同为1. 异或同一个数两次，原数不变。\n\n由此，就可以得出结果\n\n\n## 答案\n\n#### 常规解法：\n\n\n```\nclass Solution {\n    fun singleNumber(nums: IntArray): Int {\n        val map = mutableMapOf<String,String>()\n        for (num in nums) {\n            if (!map.keys.contains(num.toString())){\n                map[num.toString()] = \"\"\n            } else {\n                map[num.toString()] = num.toString()\n            }\n        }\n        for (mutableEntry in map) {\n            if(mutableEntry.value == \"\") return mutableEntry.key.toInt()\n        }\n        return 0\n    }\n}\n```\n\n\n#### 巧妙解法\n\n\n```\n    fun singleNumber(nums: IntArray): Int {\n        var result = 0\n        for (num in nums) {\n            result = result xor num\n        }\n        return result\n    }\n```\n"},{"articleName":"两数之和 II - 输入有序数组(简单)","createTime":"2020-01-31T09:53:51.000","lastModifiedTime":"2020-01-31T09:53:51.000","tag":"","summary":" 题目描述\n\n给定一个已按照 ***升序排列*** 的有序数组，找到两个数使得它们相加之和等于目","imageAddress":"","articleAddress":"/config/topic/两数之和 II - 输入有序数组(简单).md","articleContent":"## 题目描述\n\n给定一个已按照 ***升序排列*** 的有序数组，找到两个数使得它们相加之和等于目标数。\n\n函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。\n\n**说明:**\n- 返回的下标值（index1 和 index2）不是从零开始的。\n- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素\n\n**示例:**\n\n\n```\n输入: numbers = [2, 7, 11, 15], target = 9\n输出: [1,2]\n解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\n```\n\n\n## 解题思路\n\n#### 思路一\n\n常规思路，直接两个for循环，找到为止。\n\n\n#### 思路二\n\n根据本题的题干，输入的数组是一个 **升序数组** 所以我们完全可以同时进行首位一起查找\n\n\n## 答案\n\n#### 常规解法\n\n\n```\n    fun twoSum(numbers: IntArray, target: Int): IntArray {\n        for (i in 0 until  numbers.size - 1){\n            for (j in i+1 until numbers.size){\n                if(numbers[i] + numbers[j] == target){\n                    return intArrayOf(i+1,j+1)\n                }\n            }\n        }\n        return intArrayOf()\n    }\n```\n\n\n#### 双指针解法\n\n\n```\n    fun twoSum(numbers: IntArray, target: Int): IntArray {\n        var left = 0\n        var right = numbers.size-1\n        while (left < right){\n            val sum = numbers[left] + numbers[right];\n            if(sum == target){\n                return intArrayOf(left+1,right+1)\n            } else if(sum < target){\n                left++\n            } else{\n                right--\n            }\n        }\n        return intArrayOf()\n    }\n```\n"},{"articleName":"求众数(简单)","createTime":"2020-01-31T09:53:43.000","lastModifiedTime":"2020-01-31T09:53:43.000","tag":"","summary":" 题目描述\n\n给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ``⌊ ","imageAddress":"","articleAddress":"/config/topic/求众数(简单).md","articleContent":"## 题目描述\n\n给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ``⌊ n/2 ⌋`` 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在众数。\n\n**示例 1:**\n\n\n```\n输入: [3,2,3]\n输出: 3\n```\n\n**示例 2:**\n\n\n```\n输入: [2,2,1,1,1,2,2]\n输出: 2\n```\n\n## 解题思路\n\n#### 常规思路\n\n记录每个数字出现的次数，出现次数超过 n/2 的那个就是\n\n\n#### 偷懒思路\n\n通过系统提供的api将数组排序，由于众数的个数大于 n/2 ，所以排序后最中间的那个肯定就数众数\n\n\n#### 有意思的思路\n\n因为众数的个数是大于 n/2的，所以数组众数最多。于是我们可以从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个众数\n\n\n## 答案\n\n#### 常规答案\n\n\n```\n    fun majorityElement(nums: IntArray): Int {\n        val map = mutableMapOf<Int,Int>()\n        for (num in nums) {\n            val value = map[num]\n            if(value == null){\n                map[num] = 1\n            } else {\n                map[num] = value+1\n            }\n        }\n        for (mutableEntry in map) {\n            if(mutableEntry.value > nums.size / 2) return mutableEntry.key\n        }\n        return 0\n    }\n```\n\n\n#### 偷懒答案\n\n\n```\n    fun majorityElement(nums: IntArray): Int {\n        nums.sort()\n        return nums[nums.size / 2]\n    }\n```\n\n\n#### 有意思的答案\n\n\n```\n    fun majorityElement(nums: IntArray): Int {\n        var number = nums[0]\n        var counter = 1\n        for (index in 1 until nums.size - 1) {\n            if(nums[index] == number){\n                counter++\n            } else {\n                counter--\n                if(counter == 0) number = nums[index + 1]\n            }\n        }\n        return number\n    }\n```\n"},{"articleName":"移动零(简单)","createTime":"2020-01-31T09:53:37.000","lastModifiedTime":"2020-01-31T09:53:37.000","tag":"","summary":" 题目描述\n\n给定一个数组 ``nums``，编写一个函数将所有 ``0`` 移动到数组的末尾，","imageAddress":"","articleAddress":"/config/topic/移动零(简单).md","articleContent":"## 题目描述\n\n给定一个数组 ``nums``，编写一个函数将所有 ``0`` 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n**示例:**\n\n\n```\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n```\n\n**说明:**\n\n    1.必须在原数组上操作，不能拷贝额外的数组。 \n    2.尽量减少操作次数。\n    \n    \n    \n## 解题思路\n\n#### 一般思路\n\n将移动后元素放入一个列表中，然后根据列表去移动数组\n\n#### 优化思路\n\n根据题目的要求，不可以拷贝额外的数组，所以上面的思路虽然可以解出题目，但是还是不符合要求。\n\n\n我们可以先将所有的非0元素移动到最前面，然后将后面的所有元素置0即可。虽然看起来比较简单，但是实际的操作还是非常精妙的，所以这里记录下来。\n\n\n## 答案\n\n#### 一般答案\n\n\n```\n    fun moveZeroes(nums: IntArray): Unit {\n        if (nums.size < 2) return\n        val list = nums.toMutableList()\n        var index = 0\n        var zeroNum = 0\n        while (index < list.size - 1 - zeroNum){\n            val num = list[index]\n            if(num == 0){\n                list.removeAt(index)\n                list.add(0)\n                zeroNum++\n            } else {\n                index++\n            }\n        }\n        for (i in nums.indices) {\n            nums[i] = list[i]\n        }\n    }\n```\n\n\n#### 优化答案\n\n\n```\n    fun moveZeroes(nums: IntArray): Unit {\n        var index = 0\n        nums.forEach {\n            if (it != 0) {\n                nums[index] = it\n                index++\n            }\n        }\n        while (index < nums.size) {\n            nums[index] = 0\n            index++\n        }\n    }\n```\n"},{"articleName":"Nim 游戏(简单)","createTime":"2020-01-31T09:53:32.000","lastModifiedTime":"2020-01-31T09:53:32.000","tag":"","summary":" 题目描述\n\n你和你的朋友，两个人一起玩 ``Nim`` 游戏：桌子上有一堆石头，每次你们轮流拿","imageAddress":"","articleAddress":"/config/topic/Nim 游戏(简单).md","articleContent":"## 题目描述\n\n你和你的朋友，两个人一起玩 ``Nim`` 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。\n\n你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。\n\n**示例:**\n\n```\n输入: 4\n输出: false \n解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；\n    因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。\n```\n\n## 解题思路\n\n这题想复杂了，就会真的很复杂。但是只要发现了这道题目的本质，就非常的简单...简单到不可思议，所以记录一下\n\n由于每个人每次最多能拿 **3** 块石头，所以最后当面前的石头数量低于 **3** 时，你可以拿走全部的石头，你就赢了。\n\n当石头数量为 **4** 时，无论你怎么操作，最后总会给对手留下可以拿完的石头。但是如果为 **5块**、**6块**、**7块**时，你总是可以想办法留下让对手无法一次拿完的石头，这样你是可以赢的。  \n所以只要避免轮到你时，还剩下4块石头即可。同理，**8块**、**12块**也是一样的，也就是说，石头数量不能为4的倍数。\n\n\n## 答案\n\n\n```\n    fun canWinNim(n: Int): Boolean {\n        return (n % 4 != 0);\n    }\n```\n"}]